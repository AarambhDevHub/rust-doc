<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://aarambhdevhub.github.io/rust-doc/main.css">
    <link rel="icon" href="https://www.rust-lang.org/static/images/favicon-16x16.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> Rust Programming Course! | String Slices </title>
</head>
<body>

<main>
    
    <nav>
            <a href="https:&#x2F;&#x2F;aarambhdevhub.github.io&#x2F;rust-doc&#x2F;">
                        <img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="logo"/>
                    </a>
                <!-- -->

            <a href="javascript:void(0);" onclick="burger()" id="mobile" class="ms-Icon--GlobalNavButton"></a>
            <div id="trees">
                <input class="tree-toggle" type="checkbox" id="day-1-introduction"
                           />
                    <label class="tree-toggle-label"
                           for="day-1-introduction">Day 1: Introduction</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-1/">What is Rust and why use it?</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-2/">Installing Rust Toolchain (rustup, cargo)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-3/">Setting up Development (VS Code + Hello World)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-4/">Understanding Cargo Project Structure</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-2-basic-syntax-variables"
                           />
                    <label class="tree-toggle-label"
                           for="day-2-basic-syntax-variables">Day 2: Basic Syntax &amp; Variables</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-1/">Variables and Mutability in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-2/">Data Types in Rust: Integers, Floats, Booleans, and Characters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-3/">Constants vs Variables</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-4/">Understanding Shadowing in Rust: A Practical Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-5/">Basic Input&#x2F;Output</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-3-functions-control-flow"
                           />
                    <label class="tree-toggle-label"
                           for="day-3-functions-control-flow">Day 3: Functions &amp; Control Flow</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-1/">Function Syntax and Parameters in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-2/">Return Values and Expressions vs Statements</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-3/">If&#x2F;Else Statements in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-4/">Match Expressions in Rust: Powerful Pattern Matching</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-5/">Loops in Rust: loop, while, for Explained</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-4-data-types-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-4-data-types-deep-dive">Day 4: Data Types Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-1/">Compound Types (Tuples, Arrays)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-2/">String vs &amp;str in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-3/">Vector Basics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-4/">Type Annotations and Inference in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-5/">Practical Rust Exercises</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-5-practice-review"
                           />
                    <label class="tree-toggle-label"
                           for="day-5-practice-review">Day 5: Practice &amp; Review</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 5/chapter-1/">Day 5: Practice &amp; Review</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-6-ownership-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-6-ownership-fundamentals">Day 6: Ownership Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-1/">Ownership in Rust: A Detailed Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-2/">Stack vs Heap in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-3/">Understanding Ownership in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-4/">Move Semantics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-5/">Copy Trait in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-7-references-borrowing"
                           />
                    <label class="tree-toggle-label"
                           for="day-7-references-borrowing">Day 7: References &amp; Borrowing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-1/">Immutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-2/">Mutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-3/">Borrowing Rules</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-4/">Reference Lifetime Basics</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-5/">Common Borrowing Errors and Solutions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-8-slices"
                           checked/>
                    <label class="tree-toggle-label"
                           for="day-8-slices">Day 8: Slices</label>

                    <ul class="subtree">
                        <li class="active">
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/">String Slices</a>
                            </li>

                            
                                    
                                    
                                        <ul id="toc">
                                            <li><a href="
                                                        https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#string-slices-str-in-rust-comprehensive-documentation">String Slices (&amp;str) in Rust: Comprehensive Documentation</a>
                                                    <ul>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#what-are-string-slices">What are String Slices?</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#memory-layout-of-string-slices">Memory Layout of String Slices</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#types-of-string-slices">Types of String Slices</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#string-slice-operations">String Slice Operations</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#unicode-and-utf-8-handling">Unicode and UTF-8 Handling</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#string-slice-vs-string-conversion">String Slice vs String Conversion</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#string-slice-lifetimes">String Slice Lifetimes</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#pattern-matching-with-string-slices">Pattern Matching with String Slices</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#common-string-slice-patterns">Common String Slice Patterns</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#performance-considerations">Performance Considerations</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#best-practices-for-string-slices">Best Practices for String Slices</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#common-pitfalls-and-solutions">Common Pitfalls and Solutions</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/#summary-and-key-takeaways">Summary and Key Takeaways</a>
                                                                </li>
                                                            </ul>
                                                    </li>
                                            </ul>
                                    <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-2/">Array Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-3/">Slice Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-4/">Practical Applications</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-5/">Memory Safety Benefits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-9-advanced-ownership"
                           />
                    <label class="tree-toggle-label"
                           for="day-9-advanced-ownership">Day 9: Advanced Ownership</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-1/">Clone Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-2/">Drop Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-3/">RAII Pattern</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-4/">Memory Management Comparison with Other Languages</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-5/">Best Practices (Advanced Ownership)</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-10-ownership-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-10-ownership-practice">Day 10: Ownership Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-1/">Complex Ownership Scenarios</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-2/">Debugging Ownership Errors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-3/">Code Refactoring Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-4/">Group Problem-Solving</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-11-structs-basics"
                           />
                    <label class="tree-toggle-label"
                           for="day-11-structs-basics">Day 11: Structs Basics</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-1/">Defining and Instantiating Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-2/">Field Access and Modification</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-3/">Tuple Structs and Unit Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-4/">Struct Update Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/">Ownership of Struct Data</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-12-methods-associated-functions"
                           />
                    <label class="tree-toggle-label"
                           for="day-12-methods-associated-functions">Day 12: Methods &amp; Associated Functions</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-1/">Implementing Methods with impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-2/">&amp;self, &amp;mut self, and self</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-3/">Associated Functions (like Constructors)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-4/">Multiple impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-5/">Method Chaining</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-13-advanced-struct-concepts"
                           />
                    <label class="tree-toggle-label"
                           for="day-13-advanced-struct-concepts">Day 13: Advanced Struct Concepts</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-1/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-2/">Debug Trait and Custom Formatting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-3/">Builder Pattern Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-4/">Struct Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-5/">Best Practices for Struct Design</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-14-enums-pattern-matching"
                           />
                    <label class="tree-toggle-label"
                           for="day-14-enums-pattern-matching">Day 14: Enums &amp; Pattern Matching</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-1/">Defining Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-2/">Enum Variants with Data</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-3/">Option&lt;T&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-4/">Result&lt;T, E&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-5/">Advanced Match Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-15-practice-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-15-practice-project">Day 15: Practice Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 15/chapter-1/">Building a Simple CLI Calculator in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-16-vectors"
                           />
                    <label class="tree-toggle-label"
                           for="day-16-vectors">Day 16: Vectors</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-1/">Creating and Updating Vectors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-2/">Vector Methods: push, pop, iter</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-3/">Accessing Vector Elements Safely</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-4/">Vector of Different Types with Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-5/">Performance Considerations</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-17-hashmaps-other-collections"
                           />
                    <label class="tree-toggle-label"
                           for="day-17-hashmaps-other-collections">Day 17: HashMaps &amp; Other Collections</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-1/">HashMap Creation and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-2/">Keys and Values Ownership</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-3/">HashMap Methods and Iteration</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-4/">When to Use Different Collections</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/">BTreeMap Introduction</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-18-error-handling"
                           />
                    <label class="tree-toggle-label"
                           for="day-18-error-handling">Day 18: Error Handling</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-1/">Panic! and When to Use It</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-2/">Result&lt;T, E&gt; in Depth</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-3/">The ? Operator in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-4/">Creating Custom Error Types in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-5/">Error Propagation Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-19-strings-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-19-strings-deep-dive">Day 19: Strings Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-1/">String vs &amp;str Revisited</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-2/">String Methods and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-5/">Performance Considerations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-3/">UTF-8 and Character Encoding</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-4/">String Concatenation Techniques</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-20-mini-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-20-mini-project">Day 20: Mini Project</label>

                    <ul class="subtree">
                        </ul>
                <input class="tree-toggle" type="checkbox" id="day-21-generic-functions-structs"
                           />
                    <label class="tree-toggle-label"
                           for="day-21-generic-functions-structs">Day 21: Generic Functions &amp; Structs</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-1/">Generic Function Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-2/">Generic Structs and Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-3/">Type Parameters and Constraints</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-4/">Monomorphization Concept</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-5/">Generic Collections</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-22-traits-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-22-traits-fundamentals">Day 22: Traits Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-1/">Defining Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-2/">Implementing Traits for Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-3/">Default Implementations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-4/">Trait as Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-5/">Trait Bounds</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-23-advanced-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-23-advanced-traits">Day 23: Advanced Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-1/">Trait Objects and Dynamic Dispatch</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-2/">Supertraits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-3/">Associated Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-4/">Orphan Rule</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-5/">Coherence Rules</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-24-standard-library-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-24-standard-library-traits">Day 24: Standard Library Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-1/">Iterator Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-2/">From and Into Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-3/">Display and Debug Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-4/">Clone and Copy Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-5/">PartialEq and Eq Traits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-25-trait-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-25-trait-practice">Day 25: Trait Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-1/">Custom Trait Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-2/">Generic Programming Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-3/">Trait Object Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-4/">Performance Implications</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-26-lifetime-annotations"
                           />
                    <label class="tree-toggle-label"
                           for="day-26-lifetime-annotations">Day 26: Lifetime Annotations</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-1/">Why Lifetimes Exist</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-2/">Lifetime Annotation Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-3/">Function Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-4/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-5/">Lifetime Elision Rules</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-27-advanced-lifetimes"
                           />
                    <label class="tree-toggle-label"
                           for="day-27-advanced-lifetimes">Day 27: Advanced Lifetimes</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-1/">Static Lifetime</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-2/">Lifetime Subtyping</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-3/">Higher-Ranked Trait Bounds</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-4/">Common Lifetime Patterns</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-5/">Debugging Lifetime Errors</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-28-smart-pointers"
                           />
                    <label class="tree-toggle-label"
                           for="day-28-smart-pointers">Day 28: Smart Pointers</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-1/">Box&lt;T&gt; for Heap Allocation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-2/">Rc&lt;T&gt; for Reference Counting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-3/">RefCell&lt;T&gt; for Interior Mutability</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-4/">Weak&lt;T&gt; References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-5/">Memory Leak Prevention</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-29-concurrency-preparation"
                           />
                    <label class="tree-toggle-label"
                           for="day-29-concurrency-preparation">Day 29: Concurrency Preparation</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-1/">Arc&lt;T&gt; for Atomic Reference Counting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-2/">Send and Sync Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-3/">Thread Safety Concepts</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-4/">Shared State Challenges</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-5/">Lock-Free Programming Introduction</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-30-memory-management-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-30-memory-management-project">Day 30: Memory Management Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-1/">Building a Simple Data Structure</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-2/">Using Smart Pointers Effectively</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-3/">Memory Usage Optimization</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-4/">Performance Benchmarking</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-31-closures"
                           />
                    <label class="tree-toggle-label"
                           for="day-31-closures">Day 31: Closures</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-1/">Closure Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-2/">Capturing Environment</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-3/">Fn, FnMut, and FnOnce Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-4/">Moving Closures</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-5/">Closures vs Functions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-32-iterators-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-32-iterators-deep-dive">Day 32: Iterators Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-1/">Iterator Trait Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-2/">Lazy Evaluation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-3/">Iterator Adaptors (map, filter, etc.)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-4/">Consumer Adaptors (collect, fold, etc.)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-5/">Custom Iterators</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-32-iterators-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-32-iterators-deep-dive">Day 32: Iterators Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-1/">Higher-Order Functions</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-2/">Function Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-3/">Immutable Data Patterns</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-4/">Functional Error Handling</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-5/">Performance of Functional Style</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-34-advanced-iterator-patterns"
                           />
                    <label class="tree-toggle-label"
                           for="day-34-advanced-iterator-patterns">Day 34: Advanced Iterator Patterns</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-1/">Chain, Zip, Enumerate</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-2/">Flat_map and Filter_map</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/">Custom Iterator Implementations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-4/">Parallel Iterators (Rayon Introduction)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-5/">Iterator Performance Optimization</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-35-functional-programming-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-35-functional-programming-project">Day 35: Functional Programming Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 35/chapter-1/">Functional Programming Project</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-36-unit-testing"
                           />
                    <label class="tree-toggle-label"
                           for="day-36-unit-testing">Day 36: Unit Testing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 36/chapter-1/">Writing Test Functions</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 36/chapter-2/">Assert Macros</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 36/chapter-3/">Test Organization</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 36/chapter-4/">Running Tests with Cargo</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 36/chapter-5/">Test-Driven Development</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-37-integration-testing"
                           />
                    <label class="tree-toggle-label"
                           for="day-37-integration-testing">Day 37: Integration Testing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 37/chapter-1/">Integration Test Structure</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 37/chapter-2/">Testing Public API</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 37/chapter-3/">Test Utilities and Helpers</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 37/chapter-4/">Mocking and Test Doubles</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 37/chapter-5/">Test Data Management</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-38-property-based-testing"
                           />
                    <label class="tree-toggle-label"
                           for="day-38-property-based-testing">Day 38: Property-Based Testing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 38/chapter-1/">QuickCheck Concepts</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 38/chapter-2/">Proptest Library Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 38/chapter-3/">Generating Test Data</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 38/chapter-4/">Property Definition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 38/chapter-5/">Shrinking and Debugging</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-39-documentation"
                           />
                    <label class="tree-toggle-label"
                           for="day-39-documentation">Day 39: Documentation</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 39/chapter-1/">Writing Documentation Comments</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 39/chapter-2/">Generating Docs with cargo doc</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 39/chapter-3/">Documentation Tests</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 39/chapter-4/">Examples in Documentation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 39/chapter-5/">Documentation Best Practices</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-40-testing-workshop"
                           />
                    <label class="tree-toggle-label"
                           for="day-40-testing-workshop">Day 40: Testing Workshop</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 40/chapter-1/">Comprehensive Testing Exercise</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 40/chapter-3/">Continuous Integration Setup</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 40/chapter-4/">Testing Strategies Discussion</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 40/chapter-2/">Code Coverage Analysis</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-41-thread-basics"
                           />
                    <label class="tree-toggle-label"
                           for="day-41-thread-basics">Day 41: Thread Basics</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 41/chapter-1/">Creating and Joining Threads</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 41/chapter-2/">Thread::spawn Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 41/chapter-3/">Message Passing with Channels</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 41/chapter-4/">Thread Panics and Handling</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 41/chapter-5/">Thread Local Storage</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-42-message-passing"
                           />
                    <label class="tree-toggle-label"
                           for="day-42-message-passing">Day 42: Message Passing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 42/chapter-1/">Channels (mpsc)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 42/chapter-2/">Synchronous vs Asynchronous Channels</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 42/chapter-3/">Multiple Producers, Single Consumer</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 42/chapter-4/">Deadlock Avoidance</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 42/chapter-5/">Channel Patterns and Best Practices</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-43-shared-state-concurrency"
                           />
                    <label class="tree-toggle-label"
                           for="day-43-shared-state-concurrency">Day 43: Shared State Concurrency</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 43/chapter-1/">Mutex and Arc Combination</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 43/chapter-2/">RwLock for Read-Write Access</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 43/chapter-3/">Atomic Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 43/chapter-4/">Lock-Free Data Structures</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 43/chapter-5/">Performance Considerations</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-44-parallel-processing"
                           />
                    <label class="tree-toggle-label"
                           for="day-44-parallel-processing">Day 44: Parallel Processing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 44/chapter-1/">Rayon Library Introduction</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 44/chapter-2/">Parallel Iterators</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 44/chapter-3/">Work Stealing</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 44/chapter-4/">Parallel Algorithms</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 44/chapter-5/">When to Use Parallelism</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-45-concurrency-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-45-concurrency-project">Day 45: Concurrency Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 45/chapter-1/">Day 45 (Friday): Concurrency Project</a>
                            </li>

                            </ul>
                </div>
        </nav>
    <article>

        <div id="on_right">
                <span id="search-ico" class="ms-Icon--Search"></span>
            </div>
            <div class="search-container">
                <input id="search" type="search" placeholder="Search as you type...">
                <div class="search-results">
                    <div class="search-results__header"></div>
                    <ul class="search-results__items"></ul>
                </div>
            </div>
        <div id="wrap">
            
        <h1 id="string-slices-str-in-rust-comprehensive-documentation">String Slices (&amp;str) in Rust: Comprehensive Documentation</h1>
<p>Building on your understanding of borrowing rules and reference lifetimes, let's explore <strong>string slices</strong> (<code>&amp;str</code>) - one of Rust's most fundamental and frequently used types. String slices are immutable references to sequences of UTF-8 bytes and are central to efficient string handling in Rust.</p>
<h2 id="what-are-string-slices">What are String Slices?</h2>
<p>A <strong>string slice</strong> (<code>&amp;str</code>) is an <strong>immutable reference</strong> to a contiguous sequence of UTF-8 bytes stored somewhere in memory. Unlike <code>String</code>, which owns its data on the heap, <code>&amp;str</code> is a <strong>borrowed view</strong> into existing string data that can live in various memory locations.</p>
<h3 id="core-characteristics">Core Characteristics</h3>
<ul>
<li><strong>Immutable reference</strong> - Cannot modify the underlying string data</li>
<li><strong>UTF-8 encoded</strong> - Guarantees valid Unicode text</li>
<li><strong>Zero-cost</strong> - No heap allocation, just a pointer and length</li>
<li><strong>Versatile</strong> - Can reference data in binary, heap, or stack memory</li>
<li><strong>Sized at runtime</strong> - Length determined when the slice is created</li>
</ul>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> owned = String::from(&quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;);  </span><span style="color:#a7adba;">// String owns heap data
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice = &amp;owned[</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">5</span><span>];                   </span><span style="color:#a7adba;">// &amp;str references part of String
</span><span>    </span><span style="color:#b48ead;">let</span><span> literal = &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;;              </span><span style="color:#a7adba;">// &amp;str pointing to binary data
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice: </span><span style="color:#d08770;">{}</span><span>&quot;, slice);    </span><span style="color:#a7adba;">// &quot;Hello&quot;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Literal: </span><span style="color:#d08770;">{}</span><span>&quot;, literal); </span><span style="color:#a7adba;">// &quot;Hello, world!&quot;
</span><span>}
</span></code></pre>
<h2 id="memory-layout-of-string-slices">Memory Layout of String Slices</h2>
<p>A string slice is a <strong>fat pointer</strong> consisting of two components:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Conceptual representation of &amp;str
</span><span style="color:#b48ead;">struct </span><span>StrSlice {
</span><span>    </span><span style="color:#bf616a;">ptr</span><span>: </span><span style="color:#b48ead;">*const u8</span><span>,  </span><span style="color:#a7adba;">// Pointer to the first byte
</span><span>    </span><span style="color:#bf616a;">len</span><span>: </span><span style="color:#b48ead;">usize</span><span>,      </span><span style="color:#a7adba;">// Length in bytes (not characters!)
</span><span>}
</span></code></pre>
<h3 id="visual-memory-layout">Visual Memory Layout</h3>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>String in heap:     H  e  l  l  o  ,     w  o  r  l  d  !
</span><span>                    ^                    ^
</span><span>                    |                    |
</span><span>&amp;str slice:      [ptr]---------------[len: 5]
</span><span>                 Points to &#39;H&#39;        5 bytes long
</span><span>
</span><span>String literal:     H  e  l  l  o  \0  (in binary/static memory)
</span><span>                    ^
</span><span>                    |
</span><span>&amp;str:            [ptr]--------[len: 5]
</span></code></pre>
<h3 id="memory-layout-example">Memory Layout Example</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = String::from(&quot;</span><span style="color:#a3be8c;">Hello, Rust!</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice = &amp;text[</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">5</span><span>];  </span><span style="color:#a7adba;">// &quot;Hello&quot;
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">String address: </span><span style="color:#d08770;">{:p}</span><span>&quot;, text.</span><span style="color:#96b5b4;">as_ptr</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice address: </span><span style="color:#d08770;">{:p}</span><span>&quot;, slice.</span><span style="color:#96b5b4;">as_ptr</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice length: </span><span style="color:#d08770;">{}</span><span>&quot;, slice.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Same address: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">as_ptr</span><span>() == slice.</span><span style="color:#96b5b4;">as_ptr</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Size comparison
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Size of String: </span><span style="color:#d08770;">{}</span><span>&quot;, std::mem::size_of::());     </span><span style="color:#a7adba;">// 24 bytes
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Size of &amp;str: </span><span style="color:#d08770;">{}</span><span>&quot;, std::mem::size_of::());         </span><span style="color:#a7adba;">// 16 bytes
</span><span>}
</span></code></pre>
<h2 id="types-of-string-slices">Types of String Slices</h2>
<h3 id="1-string-literals-static-str">1. String Literals (<code>&amp;'static str</code>)</h3>
<p>String literals are embedded in the program binary and have a <code>'static</code> lifetime:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> literal: &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>= &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;;  </span><span style="color:#a7adba;">// Lives for entire program
</span><span>    </span><span style="color:#b48ead;">let</span><span> another = &quot;</span><span style="color:#a3be8c;">This is also a string literal</span><span>&quot;; </span><span style="color:#a7adba;">// Type inferred as &amp;str
</span><span>
</span><span>    </span><span style="color:#a7adba;">// String literals are stored in read-only memory
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Literal: </span><span style="color:#d08770;">{}</span><span>&quot;, literal);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Address: </span><span style="color:#d08770;">{:p}</span><span>&quot;, literal.</span><span style="color:#96b5b4;">as_ptr</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Can be used anywhere a &amp;str is expected
</span><span>    </span><span style="color:#96b5b4;">print_str</span><span>(literal);
</span><span>    </span><span style="color:#96b5b4;">print_str</span><span>(&quot;</span><span style="color:#a3be8c;">Direct literal</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print_str</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Got string: </span><span style="color:#d08770;">{}</span><span>&quot;, s);
</span><span>}
</span></code></pre>
<h3 id="2-slices-from-string">2. Slices from String</h3>
<p>Creating slices from owned <code>String</code> data:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> owned = String::from(&quot;</span><span style="color:#a3be8c;">Hello, beautiful world!</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Various slicing operations
</span><span>    </span><span style="color:#b48ead;">let</span><span> full_slice = &amp;owned[..];        </span><span style="color:#a7adba;">// Entire string
</span><span>    </span><span style="color:#b48ead;">let</span><span> hello = &amp;owned[</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">5</span><span>];           </span><span style="color:#a7adba;">// &quot;Hello&quot;
</span><span>    </span><span style="color:#b48ead;">let</span><span> beautiful = &amp;owned[</span><span style="color:#d08770;">7</span><span>..</span><span style="color:#d08770;">16</span><span>];      </span><span style="color:#a7adba;">// &quot;beautiful&quot;
</span><span>    </span><span style="color:#b48ead;">let</span><span> world = &amp;owned[</span><span style="color:#d08770;">17</span><span>..</span><span style="color:#d08770;">22</span><span>];         </span><span style="color:#a7adba;">// &quot;world&quot;
</span><span>    </span><span style="color:#b48ead;">let</span><span> from_index = &amp;owned[</span><span style="color:#d08770;">7</span><span>..];       </span><span style="color:#a7adba;">// &quot;beautiful world!&quot;
</span><span>    </span><span style="color:#b48ead;">let</span><span> to_index = &amp;owned[..</span><span style="color:#d08770;">16</span><span>];        </span><span style="color:#a7adba;">// &quot;Hello, beautiful&quot;
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Full: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, full_slice);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, hello);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Beautiful: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, beautiful);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">World: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, world);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">From 7: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, from_index);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">To 16: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, to_index);
</span><span>}
</span></code></pre>
<h3 id="3-slices-from-arrays-and-vectors">3. Slices from Arrays and Vectors</h3>
<p>String slices can reference data in various collection types:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#a7adba;">// From byte array (if valid UTF-8)
</span><span>    </span><span style="color:#b48ead;">let</span><span> bytes = [</span><span style="color:#d08770;">72</span><span>, </span><span style="color:#d08770;">101</span><span>, </span><span style="color:#d08770;">108</span><span>, </span><span style="color:#d08770;">108</span><span>, </span><span style="color:#d08770;">111</span><span>]; </span><span style="color:#a7adba;">// &quot;Hello&quot; in ASCII
</span><span>    </span><span style="color:#b48ead;">let</span><span> from_bytes = std::str::from_utf8(&amp;bytes).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">From bytes: </span><span style="color:#d08770;">{}</span><span>&quot;, from_bytes);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// From Vec (if valid UTF-8)
</span><span>    </span><span style="color:#b48ead;">let</span><span> vec_bytes = vec![</span><span style="color:#d08770;">87</span><span>, </span><span style="color:#d08770;">111</span><span>, </span><span style="color:#d08770;">114</span><span>, </span><span style="color:#d08770;">108</span><span>, </span><span style="color:#d08770;">100</span><span>]; </span><span style="color:#a7adba;">// &quot;World&quot;
</span><span>    </span><span style="color:#b48ead;">let</span><span> from_vec = std::str::from_utf8(&amp;vec_bytes).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">From vec: </span><span style="color:#d08770;">{}</span><span>&quot;, from_vec);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// From string in vector
</span><span>    </span><span style="color:#b48ead;">let</span><span> strings = vec![String::from(&quot;</span><span style="color:#a3be8c;">first</span><span>&quot;), String::from(&quot;</span><span style="color:#a3be8c;">second</span><span>&quot;)];
</span><span>    </span><span style="color:#b48ead;">let</span><span> first_slice = &amp;strings[</span><span style="color:#d08770;">0</span><span>][..];  </span><span style="color:#a7adba;">// &amp;str from String in Vec
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">First slice: </span><span style="color:#d08770;">{}</span><span>&quot;, first_slice);
</span><span>}
</span></code></pre>
<h2 id="string-slice-operations">String Slice Operations</h2>
<h3 id="basic-operations">Basic Operations</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello, Rust programming!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Length operations
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Length in bytes: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">len</span><span>());           </span><span style="color:#a7adba;">// 23
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Length in chars: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">count</span><span>()); </span><span style="color:#a7adba;">// 23
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Is empty: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">is_empty</span><span>());             </span><span style="color:#a7adba;">// false
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Character operations
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">First char: </span><span style="color:#d08770;">{:?}</span><span>&quot;, text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">next</span><span>());     </span><span style="color:#a7adba;">// Some(&#39;H&#39;)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Last char: </span><span style="color:#d08770;">{:?}</span><span>&quot;, text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">last</span><span>());      </span><span style="color:#a7adba;">// Some(&#39;!&#39;)
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Searching
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Contains &#39;Rust&#39;: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">contains</span><span>(&quot;</span><span style="color:#a3be8c;">Rust</span><span>&quot;));          </span><span style="color:#a7adba;">// true
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Starts with &#39;Hello&#39;: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">starts_with</span><span>(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;)); </span><span style="color:#a7adba;">// true
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Ends with &#39;!&#39;: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">ends_with</span><span>(&quot;</span><span style="color:#a3be8c;">!</span><span>&quot;));             </span><span style="color:#a7adba;">// true
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Finding positions
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Position of &#39;Rust&#39;: </span><span style="color:#d08770;">{:?}</span><span>&quot;, text.</span><span style="color:#96b5b4;">find</span><span>(&quot;</span><span style="color:#a3be8c;">Rust</span><span>&quot;));        </span><span style="color:#a7adba;">// Some(7)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Position of &#39;Python&#39;: </span><span style="color:#d08770;">{:?}</span><span>&quot;, text.</span><span style="color:#96b5b4;">find</span><span>(&quot;</span><span style="color:#a3be8c;">Python</span><span>&quot;));    </span><span style="color:#a7adba;">// None
</span><span>}
</span></code></pre>
<h3 id="string-slice-iteration">String Slice Iteration</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello, 🦀!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterate over characters
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Characters:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(i, ch) in text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        println!(&quot;  </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (Unicode: U+</span><span style="color:#d08770;">{:04X}</span><span style="color:#a3be8c;">)</span><span>&quot;, i, ch, ch as </span><span style="color:#b48ead;">u32</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterate over bytes
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Bytes:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(i, byte) in text.</span><span style="color:#96b5b4;">bytes</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        println!(&quot;  </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (0x</span><span style="color:#d08770;">{:02X}</span><span style="color:#a3be8c;">)</span><span>&quot;, i, byte, byte);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterate over char indices (byte positions)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Char indices:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(byte_index, ch) in text.</span><span style="color:#96b5b4;">char_indices</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">  Byte </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, byte_index, ch);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="string-processing">String Processing</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">  Hello, World!  </span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Trimming
</span><span>    </span><span style="color:#b48ead;">let</span><span> trimmed = text.</span><span style="color:#96b5b4;">trim</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> left_trimmed = text.</span><span style="color:#96b5b4;">trim_start</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> right_trimmed = text.</span><span style="color:#96b5b4;">trim_end</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Original: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, text);         </span><span style="color:#a7adba;">// &quot;  Hello, World!  &quot;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Trimmed: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, trimmed);       </span><span style="color:#a7adba;">// &quot;Hello, World!&quot;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Left: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, left_trimmed);     </span><span style="color:#a7adba;">// &quot;Hello, World!  &quot;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Right: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, right_trimmed);   </span><span style="color:#a7adba;">// &quot;  Hello, World!&quot;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Case operations (return new String, not &amp;str)
</span><span>    </span><span style="color:#b48ead;">let</span><span> lower = text.</span><span style="color:#96b5b4;">to_lowercase</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> upper = text.</span><span style="color:#96b5b4;">to_uppercase</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Lowercase: </span><span style="color:#d08770;">{}</span><span>&quot;, lower);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Uppercase: </span><span style="color:#d08770;">{}</span><span>&quot;, upper);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Splitting
</span><span>    </span><span style="color:#b48ead;">let</span><span> sentence = &quot;</span><span style="color:#a3be8c;">apple,banana,cherry,date</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> fruits: Vec = sentence.</span><span style="color:#96b5b4;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;).</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Fruits: </span><span style="color:#d08770;">{:?}</span><span>&quot;, fruits);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Replacing (returns new String)
</span><span>    </span><span style="color:#b48ead;">let</span><span> replaced = text.</span><span style="color:#96b5b4;">replace</span><span>(&quot;</span><span style="color:#a3be8c;">World</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Rust</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Replaced: </span><span style="color:#d08770;">{}</span><span>&quot;, replaced);
</span><span>}
</span></code></pre>
<h2 id="unicode-and-utf-8-handling">Unicode and UTF-8 Handling</h2>
<h3 id="character-vs-byte-indexing">Character vs Byte Indexing</h3>
<p><strong>Important</strong>: String indexing in Rust is <strong>byte-based</strong>, not character-based, due to UTF-8 encoding:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello, 🦀!</span><span>&quot;;  </span><span style="color:#a7adba;">// The crab emoji is 4 bytes
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Text: </span><span style="color:#d08770;">{}</span><span>&quot;, text);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Byte length: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">len</span><span>());              </span><span style="color:#a7adba;">// 10 bytes
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Character count: </span><span style="color:#d08770;">{}</span><span>&quot;, text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">count</span><span>()); </span><span style="color:#a7adba;">// 8 characters
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe slicing (must be on character boundaries)
</span><span>    </span><span style="color:#b48ead;">let</span><span> hello = &amp;text[</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">5</span><span>];     </span><span style="color:#a7adba;">// &quot;Hello&quot; - safe
</span><span>    </span><span style="color:#b48ead;">let</span><span> comma = &amp;text[</span><span style="color:#d08770;">5</span><span>..</span><span style="color:#d08770;">7</span><span>];     </span><span style="color:#a7adba;">// &quot;, &quot; - safe
</span><span>    </span><span style="color:#b48ead;">let</span><span> crab = &amp;text[</span><span style="color:#d08770;">7</span><span>..</span><span style="color:#d08770;">11</span><span>];     </span><span style="color:#a7adba;">// &quot;🦀&quot; - safe (4 bytes)
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, hello);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Comma: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, comma);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Crab: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, crab);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// This would panic - not on character boundary:
</span><span>    </span><span style="color:#a7adba;">// let invalid = &amp;text[0..8];  // Panic: byte index 8 not a char boundary
</span><span>}
</span></code></pre>
<h3 id="safe-character-operations">Safe Character Operations</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Héllo, 世界! 🦀</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Get nth character safely
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_nth_char</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">n</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Option {
</span><span>        s.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">nth</span><span>(n)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Get substring by character position safely
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_char_substring</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">start</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">len</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; String {
</span><span>        s.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">skip</span><span>(start).</span><span style="color:#96b5b4;">take</span><span>(len).</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">3rd character: </span><span style="color:#d08770;">{:?}</span><span>&quot;, </span><span style="color:#96b5b4;">get_nth_char</span><span>(text, </span><span style="color:#d08770;">2</span><span>));  </span><span style="color:#a7adba;">// Some(&#39;l&#39;)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Characters 7-9: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, </span><span style="color:#96b5b4;">get_char_substring</span><span>(text, </span><span style="color:#d08770;">7</span><span>, </span><span style="color:#d08770;">2</span><span>)); </span><span style="color:#a7adba;">// &quot;世界&quot;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe iteration
</span><span>    </span><span style="color:#b48ead;">for </span><span>(char_index, ch) in text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Character </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; (bytes: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">)</span><span>&quot;,
</span><span>                 char_index, ch, ch.</span><span style="color:#96b5b4;">len_utf8</span><span>());
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="validation-and-conversion">Validation and Conversion</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#a7adba;">// Valid UTF-8 from bytes
</span><span>    </span><span style="color:#b48ead;">let</span><span> valid_bytes = [</span><span style="color:#d08770;">72</span><span>, </span><span style="color:#d08770;">101</span><span>, </span><span style="color:#d08770;">108</span><span>, </span><span style="color:#d08770;">108</span><span>, </span><span style="color:#d08770;">111</span><span>]; </span><span style="color:#a7adba;">// &quot;Hello&quot;
</span><span>    </span><span style="color:#b48ead;">match </span><span>std::str::from_utf8(&amp;valid_bytes) {
</span><span>        Ok(s) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Valid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, s),
</span><span>        Err(e) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Invalid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, e),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Invalid UTF-8 from bytes
</span><span>    </span><span style="color:#b48ead;">let</span><span> invalid_bytes = [</span><span style="color:#d08770;">0xFF</span><span>, </span><span style="color:#d08770;">0xFE</span><span>]; </span><span style="color:#a7adba;">// Invalid UTF-8 sequence
</span><span>    </span><span style="color:#b48ead;">match </span><span>std::str::from_utf8(&amp;invalid_bytes) {
</span><span>        Ok(s) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Valid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, s),
</span><span>        Err(e) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Invalid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, e),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Lossy conversion (replaces invalid sequences with �)
</span><span>    </span><span style="color:#b48ead;">let</span><span> lossy = String::from_utf8_lossy(&amp;invalid_bytes);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Lossy conversion: </span><span style="color:#d08770;">{}</span><span>&quot;, lossy);
</span><span>}
</span></code></pre>
<h2 id="string-slice-vs-string-conversion">String Slice vs String Conversion</h2>
<h3 id="converting-str-to-string">Converting &amp;str to String</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice = &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Multiple ways to convert &amp;str to String
</span><span>    </span><span style="color:#b48ead;">let</span><span> string1 = slice.</span><span style="color:#96b5b4;">to_string</span><span>();           </span><span style="color:#a7adba;">// Most common
</span><span>    </span><span style="color:#b48ead;">let</span><span> string2 = slice.</span><span style="color:#96b5b4;">to_owned</span><span>();            </span><span style="color:#a7adba;">// Explicit ownership
</span><span>    </span><span style="color:#b48ead;">let</span><span> string3 = String::from(slice);         </span><span style="color:#a7adba;">// Explicit constructor
</span><span>    </span><span style="color:#b48ead;">let</span><span> string4 = slice.</span><span style="color:#96b5b4;">into</span><span>();               </span><span style="color:#a7adba;">// Using Into trait
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">All are equivalent:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">string1: </span><span style="color:#d08770;">{}</span><span>&quot;, string1);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">string2: </span><span style="color:#d08770;">{}</span><span>&quot;, string2);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">string3: </span><span style="color:#d08770;">{}</span><span>&quot;, string3);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">string4: </span><span style="color:#d08770;">{}</span><span>&quot;, string4);
</span><span>}
</span></code></pre>
<h3 id="converting-string-to-str">Converting String to &amp;str</h3>
<p>Rust provides automatic <strong>deref coercion</strong> from <code>String</code> to <code>&amp;str</code>:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">takes_str_slice</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Received: </span><span style="color:#d08770;">{}</span><span>&quot;, s);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> owned = String::from(&quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Automatic coercion
</span><span>    </span><span style="color:#96b5b4;">takes_str_slice</span><span>(&amp;owned);           </span><span style="color:#a7adba;">// &amp;String -&gt; &amp;str
</span><span>    </span><span style="color:#96b5b4;">takes_str_slice</span><span>(owned.</span><span style="color:#96b5b4;">as_str</span><span>());   </span><span style="color:#a7adba;">// Explicit conversion
</span><span>    </span><span style="color:#96b5b4;">takes_str_slice</span><span>(&amp;owned[..]);       </span><span style="color:#a7adba;">// Explicit slicing
</span><span>
</span><span>    </span><span style="color:#a7adba;">// String is still owned and accessible
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Still owned: </span><span style="color:#d08770;">{}</span><span>&quot;, owned);
</span><span>}
</span></code></pre>
<h2 id="string-slice-lifetimes">String Slice Lifetimes</h2>
<h3 id="lifetime-dependencies">Lifetime Dependencies</h3>
<p>String slices must not outlive the data they reference:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice: &amp;</span><span style="color:#b48ead;">str</span><span>;
</span><span>
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let</span><span> owned = String::from(&quot;</span><span style="color:#a3be8c;">temporary</span><span>&quot;);
</span><span>        slice = &amp;owned[..];  </span><span style="color:#a7adba;">// Error: owned doesn&#39;t live long enough
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;{}&quot;, slice);  // Would be dangling reference
</span><span>}
</span></code></pre>
<p><strong>Solution</strong>: Ensure proper lifetime relationships:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> owned = String::from(&quot;</span><span style="color:#a3be8c;">long-lived</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice = &amp;owned[..];  </span><span style="color:#a7adba;">// slice lifetime tied to owned
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice: </span><span style="color:#d08770;">{}</span><span>&quot;, slice);  </span><span style="color:#a7adba;">// OK: both in same scope
</span><span>}
</span></code></pre>
<h3 id="static-lifetime-slices">Static Lifetime Slices</h3>
<p>String literals have <code>'static</code> lifetime:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_greeting</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>{
</span><span>    &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;  </span><span style="color:#a7adba;">// String literal lives for entire program
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> greeting = </span><span style="color:#96b5b4;">get_greeting</span><span>();
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, greeting);  </span><span style="color:#a7adba;">// Always valid
</span><span>}
</span></code></pre>
<h3 id="function-parameters-and-lifetimes">Function Parameters and Lifetimes</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Lifetime elision - compiler infers lifetimes
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">first_word</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span>{
</span><span>    </span><span style="color:#b48ead;">match</span><span> s.</span><span style="color:#96b5b4;">find</span><span>(&#39; &#39;) {
</span><span>        Some(index) =&gt; &amp;s[</span><span style="color:#d08770;">0</span><span>..index],
</span><span>        None =&gt; s,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Explicit lifetime annotation
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longer_string</span><span>(</span><span style="color:#bf616a;">s1</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>, </span><span style="color:#bf616a;">s2</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">&#39;a str </span><span>{
</span><span>    </span><span style="color:#b48ead;">if</span><span> s1.</span><span style="color:#96b5b4;">len</span><span>() &gt; s2.</span><span style="color:#96b5b4;">len</span><span>() { s1 } </span><span style="color:#b48ead;">else </span><span>{ s2 }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> sentence = &quot;</span><span style="color:#a3be8c;">Hello beautiful world</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> first = </span><span style="color:#96b5b4;">first_word</span><span>(sentence);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">First word: </span><span style="color:#d08770;">{}</span><span>&quot;, first);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> s1 = &quot;</span><span style="color:#a3be8c;">short</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> s2 = &quot;</span><span style="color:#a3be8c;">much longer string</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> longer = </span><span style="color:#96b5b4;">longer_string</span><span>(s1, s2);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Longer: </span><span style="color:#d08770;">{}</span><span>&quot;, longer);
</span><span>}
</span></code></pre>
<h2 id="pattern-matching-with-string-slices">Pattern Matching with String Slices</h2>
<h3 id="basic-pattern-matching">Basic Pattern Matching</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">classify_input</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>{
</span><span>    </span><span style="color:#b48ead;">match</span><span> input {
</span><span>        &quot;&quot; =&gt; &quot;</span><span style="color:#a3be8c;">empty</span><span>&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">quit</span><span>&quot; | &quot;</span><span style="color:#a3be8c;">exit</span><span>&quot; | &quot;</span><span style="color:#a3be8c;">q</span><span>&quot; =&gt; &quot;</span><span style="color:#a3be8c;">quit command</span><span>&quot;,
</span><span>        s </span><span style="color:#b48ead;">if</span><span> s.</span><span style="color:#96b5b4;">starts_with</span><span>(&quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;) =&gt; &quot;</span><span style="color:#a3be8c;">greeting</span><span>&quot;,
</span><span>        s </span><span style="color:#b48ead;">if</span><span> s.parse::().</span><span style="color:#96b5b4;">is_ok</span><span>() =&gt; &quot;</span><span style="color:#a3be8c;">number</span><span>&quot;,
</span><span>        _ =&gt; &quot;</span><span style="color:#a3be8c;">unknown</span><span>&quot;,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> inputs = [&quot;&quot;, &quot;</span><span style="color:#a3be8c;">quit</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">hello world</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">42</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">random</span><span>&quot;];
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> input in &amp;inputs {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">&#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; -&gt; </span><span style="color:#d08770;">{}</span><span>&quot;, input, </span><span style="color:#96b5b4;">classify_input</span><span>(input));
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="advanced-pattern-matching">Advanced Pattern Matching</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">analyze_command</span><span>(</span><span style="color:#bf616a;">command</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let</span><span> parts: Vec = command.</span><span style="color:#96b5b4;">split_whitespace</span><span>().</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">match</span><span> parts.</span><span style="color:#96b5b4;">as_slice</span><span>() {
</span><span>        [] =&gt; &quot;</span><span style="color:#a3be8c;">empty command</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        [&quot;</span><span style="color:#a3be8c;">help</span><span>&quot;] =&gt; &quot;</span><span style="color:#a3be8c;">showing help</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        [&quot;</span><span style="color:#a3be8c;">echo</span><span>&quot;, rest @ ..] =&gt; format!(&quot;</span><span style="color:#a3be8c;">echoing: </span><span style="color:#d08770;">{}</span><span>&quot;, rest.</span><span style="color:#96b5b4;">join</span><span>(&quot; &quot;)),
</span><span>        [&quot;</span><span style="color:#a3be8c;">set</span><span>&quot;, key, value] =&gt; format!(&quot;</span><span style="color:#a3be8c;">setting </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">{}</span><span>&quot;, key, value),
</span><span>        [&quot;</span><span style="color:#a3be8c;">get</span><span>&quot;, key] =&gt; format!(&quot;</span><span style="color:#a3be8c;">getting value for </span><span style="color:#d08770;">{}</span><span>&quot;, key),
</span><span>        [cmd, ..] =&gt; format!(&quot;</span><span style="color:#a3be8c;">unknown command: </span><span style="color:#d08770;">{}</span><span>&quot;, cmd),
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> commands = [
</span><span>        &quot;&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">help</span><span>&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">echo hello world</span><span>&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">set name Alice</span><span>&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">get name</span><span>&quot;,
</span><span>        &quot;</span><span style="color:#a3be8c;">unknown command with args</span><span>&quot;,
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> cmd in &amp;commands {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">&#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; -&gt; </span><span style="color:#d08770;">{}</span><span>&quot;, cmd, </span><span style="color:#96b5b4;">analyze_command</span><span>(cmd));
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="common-string-slice-patterns">Common String Slice Patterns</h2>
<h3 id="the-parser-pattern">The Parser Pattern</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>Parser {
</span><span>    </span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>,
</span><span>    </span><span style="color:#bf616a;">position</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Parser {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        Parser { input, position: </span><span style="color:#d08770;">0 </span><span>}
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">peek</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Option {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.input[</span><span style="color:#bf616a;">self</span><span>.position..].</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">next</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">advance</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> chars = </span><span style="color:#bf616a;">self</span><span>.input[</span><span style="color:#bf616a;">self</span><span>.position..].</span><span style="color:#96b5b4;">chars</span><span>();
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(ch) = chars.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>            </span><span style="color:#bf616a;">self</span><span>.position += ch.</span><span style="color:#96b5b4;">len_utf8</span><span>();
</span><span>            Some(ch)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            None
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">parse_word</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option {
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#bf616a;">self</span><span>.position;
</span><span>
</span><span>        </span><span style="color:#b48ead;">while let </span><span>Some(ch) = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">peek</span><span>() {
</span><span>            </span><span style="color:#b48ead;">if</span><span> ch.</span><span style="color:#96b5b4;">is_alphabetic</span><span>() {
</span><span>                </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">advance</span><span>();
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                </span><span style="color:#b48ead;">break</span><span>;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.position &gt; start {
</span><span>            Some(&amp;</span><span style="color:#bf616a;">self</span><span>.input[start..</span><span style="color:#bf616a;">self</span><span>.position])
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            None
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">skip_whitespace</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">while let </span><span>Some(ch) = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">peek</span><span>() {
</span><span>            </span><span style="color:#b48ead;">if</span><span> ch.</span><span style="color:#96b5b4;">is_whitespace</span><span>() {
</span><span>                </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">advance</span><span>();
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                </span><span style="color:#b48ead;">break</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> parser = Parser::new(&quot;</span><span style="color:#a3be8c;">hello world rust programming</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">while</span><span> parser.</span><span style="color:#96b5b4;">peek</span><span>().</span><span style="color:#96b5b4;">is_some</span><span>() {
</span><span>        parser.</span><span style="color:#96b5b4;">skip_whitespace</span><span>();
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(word) = parser.</span><span style="color:#96b5b4;">parse_word</span><span>() {
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">Word: </span><span style="color:#d08770;">{}</span><span>&quot;, word);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="the-configuration-parser-pattern">The Configuration Parser Pattern</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">parse_config</span><span>(</span><span style="color:#bf616a;">content</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; std::collections::HashMap {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> config = std::collections::HashMap::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> line in content.</span><span style="color:#96b5b4;">lines</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> line = line.</span><span style="color:#96b5b4;">trim</span><span>();
</span><span>
</span><span>        </span><span style="color:#a7adba;">// Skip empty lines and comments
</span><span>        </span><span style="color:#b48ead;">if</span><span> line.</span><span style="color:#96b5b4;">is_empty</span><span>() || line.</span><span style="color:#96b5b4;">starts_with</span><span>(&#39;</span><span style="color:#a3be8c;">#</span><span>&#39;) {
</span><span>            </span><span style="color:#b48ead;">continue</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#a7adba;">// Parse key=value pairs
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(eq_pos) = line.</span><span style="color:#96b5b4;">find</span><span>(&#39;</span><span style="color:#a3be8c;">=</span><span>&#39;) {
</span><span>            </span><span style="color:#b48ead;">let</span><span> key = line[..eq_pos].</span><span style="color:#96b5b4;">trim</span><span>();
</span><span>            </span><span style="color:#b48ead;">let</span><span> value = line[eq_pos + </span><span style="color:#d08770;">1</span><span>..].</span><span style="color:#96b5b4;">trim</span><span>();
</span><span>            config.</span><span style="color:#96b5b4;">insert</span><span>(key, value);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    config
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> config_content = </span><span style="color:#b48ead;">r</span><span>#&quot;
</span><span style="color:#a3be8c;"># Database configuration
</span><span style="color:#a3be8c;">host=localhost
</span><span style="color:#a3be8c;">port=5432
</span><span style="color:#a3be8c;">database=myapp
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;"># Cache settings
</span><span style="color:#a3be8c;">cache_size=1000
</span><span style="color:#a3be8c;">cache_ttl=3600
</span><span>&quot;#;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> config = </span><span style="color:#96b5b4;">parse_config</span><span>(config_content);
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(key, value) in &amp;config {
</span><span>        println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">{}</span><span>&quot;, key, value);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="the-template-processing-pattern">The Template Processing Pattern</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_template</span><span>(</span><span style="color:#bf616a;">template</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">vars</span><span>: &amp;std::collections::HashMap) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> result = String::with_capacity(template.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> chars = template.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">peekable</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some(ch) = chars.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if</span><span> ch == &#39;</span><span style="color:#a3be8c;">{</span><span>&#39; &amp;&amp; chars.</span><span style="color:#96b5b4;">peek</span><span>() == Some(&amp;&#39;</span><span style="color:#a3be8c;">{</span><span>&#39;) {
</span><span>            chars.</span><span style="color:#96b5b4;">next</span><span>(); </span><span style="color:#a7adba;">// consume second &#39;{&#39;
</span><span>
</span><span>            </span><span style="color:#a7adba;">// Find the closing &#39;}}&#39;
</span><span>            </span><span style="color:#b48ead;">let mut</span><span> var_name = String::new();
</span><span>            </span><span style="color:#b48ead;">let mut</span><span> found_close = </span><span style="color:#d08770;">false</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">while let </span><span>Some(ch) = chars.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>                </span><span style="color:#b48ead;">if</span><span> ch == &#39;</span><span style="color:#a3be8c;">}</span><span>&#39; &amp;&amp; chars.</span><span style="color:#96b5b4;">peek</span><span>() == Some(&amp;&#39;</span><span style="color:#a3be8c;">}</span><span>&#39;) {
</span><span>                    chars.</span><span style="color:#96b5b4;">next</span><span>(); </span><span style="color:#a7adba;">// consume second &#39;}&#39;
</span><span>                    found_close = </span><span style="color:#d08770;">true</span><span>;
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                }
</span><span>                var_name.</span><span style="color:#96b5b4;">push</span><span>(ch);
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> found_close {
</span><span>                </span><span style="color:#b48ead;">if let </span><span>Some(value) = vars.</span><span style="color:#96b5b4;">get</span><span>(var_name.</span><span style="color:#96b5b4;">as_str</span><span>()) {
</span><span>                    result.</span><span style="color:#96b5b4;">push_str</span><span>(value);
</span><span>                } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                    result.</span><span style="color:#96b5b4;">push_str</span><span>(&amp;format!(&quot;</span><span style="color:#96b5b4;">{{{{</span><span style="color:#d08770;">{}</span><span style="color:#96b5b4;">}}}}</span><span>&quot;, var_name)); </span><span style="color:#a7adba;">// Keep original
</span><span>                }
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                result.</span><span style="color:#96b5b4;">push_str</span><span>(&quot;</span><span style="color:#a3be8c;">{{</span><span>&quot;);
</span><span>                result.</span><span style="color:#96b5b4;">push_str</span><span>(&amp;var_name);
</span><span>            }
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            result.</span><span style="color:#96b5b4;">push</span><span>(ch);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    result
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> template = &quot;</span><span style="color:#a3be8c;">Hello {{name}}, welcome to {{app}}! Your score is {{score}}.</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> vars = std::collections::HashMap::new();
</span><span>    vars.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">name</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;);
</span><span>    vars.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">app</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">MyApp</span><span>&quot;);
</span><span>    vars.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">score</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">95</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">process_template</span><span>(template, &amp;vars);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Result: </span><span style="color:#d08770;">{}</span><span>&quot;, result);
</span><span>}
</span></code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="zero-copy-string-processing">Zero-Copy String Processing</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::time::Instant;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_with_copies</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec {
</span><span>    text.</span><span style="color:#96b5b4;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">s</span><span>| s.</span><span style="color:#96b5b4;">trim</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>())  </span><span style="color:#a7adba;">// Creates owned Strings
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_with_slices</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec {
</span><span>    text.</span><span style="color:#96b5b4;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">s</span><span>| s.</span><span style="color:#96b5b4;">trim</span><span>())  </span><span style="color:#a7adba;">// Returns string slices
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> data = &quot;</span><span style="color:#a3be8c;">apple, banana, cherry, date, elderberry, fig, grape</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Benchmark copying approach
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = Instant::now();
</span><span>    </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">100_000 </span><span>{
</span><span>        </span><span style="color:#b48ead;">let</span><span> _result = </span><span style="color:#96b5b4;">process_with_copies</span><span>(data);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">let</span><span> copy_time = start.</span><span style="color:#96b5b4;">elapsed</span><span>();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Benchmark slice approach
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = Instant::now();
</span><span>    </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">100_000 </span><span>{
</span><span>        </span><span style="color:#b48ead;">let</span><span> _result = </span><span style="color:#96b5b4;">process_with_slices</span><span>(data);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice_time = start.</span><span style="color:#96b5b4;">elapsed</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Copy approach: </span><span style="color:#d08770;">{:?}</span><span>&quot;, copy_time);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice approach: </span><span style="color:#d08770;">{:?}</span><span>&quot;, slice_time);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Slice is </span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">x faster</span><span>&quot;,
</span><span>             copy_time.</span><span style="color:#96b5b4;">as_nanos</span><span>() as </span><span style="color:#b48ead;">f64 </span><span>/ slice_time.</span><span style="color:#96b5b4;">as_nanos</span><span>() as </span><span style="color:#b48ead;">f64</span><span>);
</span><span>}
</span></code></pre>
<h3 id="memory-usage-comparison">Memory Usage Comparison</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> large_text = &quot;</span><span style="color:#a3be8c;">word </span><span>&quot;.</span><span style="color:#96b5b4;">repeat</span><span>(</span><span style="color:#d08770;">100_000</span><span>);  </span><span style="color:#a7adba;">// ~500KB string
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Memory-efficient: slice processing
</span><span>    </span><span style="color:#b48ead;">let</span><span> word_count = large_text.</span><span style="color:#96b5b4;">split_whitespace</span><span>().</span><span style="color:#96b5b4;">count</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Word count: </span><span style="color:#d08770;">{}</span><span>&quot;, word_count);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Memory-expensive: collecting all words
</span><span>    </span><span style="color:#b48ead;">let</span><span> all_words: Vec = large_text
</span><span>        .</span><span style="color:#96b5b4;">split_whitespace</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">s</span><span>| s.</span><span style="color:#96b5b4;">to_string</span><span>())
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Collected </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> words</span><span>&quot;, all_words.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Show memory usage difference
</span><span>    </span><span style="color:#b48ead;">let</span><span> slice_size = std::mem::size_of_val(&amp;large_text);
</span><span>    </span><span style="color:#b48ead;">let</span><span> vec_size = std::mem::size_of_val(&amp;all_words) +
</span><span>                   all_words.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">s</span><span>| s.</span><span style="color:#96b5b4;">capacity</span><span>()).sum::();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Original string: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, slice_size);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Collected words: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, vec_size);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Memory overhead: </span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">x</span><span>&quot;, vec_size as </span><span style="color:#b48ead;">f64 </span><span>/ slice_size as </span><span style="color:#b48ead;">f64</span><span>);
</span><span>}
</span></code></pre>
<h2 id="best-practices-for-string-slices">Best Practices for String Slices</h2>
<h3 id="api-design-guidelines">API Design Guidelines</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Good: Accept &amp;str for maximum flexibility
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_text</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; </span><span style="color:#b48ead;">usize </span><span>{
</span><span>    text.</span><span style="color:#96b5b4;">split_whitespace</span><span>().</span><span style="color:#96b5b4;">count</span><span>()
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Less flexible: Accepts only String
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_string</span><span>(</span><span style="color:#bf616a;">text</span><span>: String) -&gt; </span><span style="color:#b48ead;">usize </span><span>{
</span><span>    text.</span><span style="color:#96b5b4;">split_whitespace</span><span>().</span><span style="color:#96b5b4;">count</span><span>()
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Good: Return &amp;str when referencing input data
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">extract_domain</span><span>(</span><span style="color:#bf616a;">email</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Option {
</span><span>    email.</span><span style="color:#96b5b4;">find</span><span>(&#39;</span><span style="color:#a3be8c;">@</span><span>&#39;).</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">pos</span><span>| &amp;email[pos + </span><span style="color:#d08770;">1</span><span>..])
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Good: Return String when creating new data
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">format_greeting</span><span>(</span><span style="color:#bf616a;">name</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; String {
</span><span>    format!(&quot;</span><span style="color:#a3be8c;">Hello, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span>&quot;, name)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = String::from(&quot;</span><span style="color:#a3be8c;">hello world rust</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> literal = &quot;</span><span style="color:#a3be8c;">hello world rust</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Both work with &amp;str parameter
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">String: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#96b5b4;">process_text</span><span>(&amp;text));
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Literal: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#96b5b4;">process_text</span><span>(literal));
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> email = &quot;</span><span style="color:#a3be8c;">user@example.com</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(domain) = </span><span style="color:#96b5b4;">extract_domain</span><span>(email) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Domain: </span><span style="color:#d08770;">{}</span><span>&quot;, domain);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> greeting = </span><span style="color:#96b5b4;">format_greeting</span><span>(&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, greeting);
</span><span>}
</span></code></pre>
<h3 id="error-handling-with-string-slices">Error Handling with String Slices</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::str::Utf8Error;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">safe_slice</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">start</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">end</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Result {
</span><span>    </span><span style="color:#b48ead;">if</span><span> start &gt; s.</span><span style="color:#96b5b4;">len</span><span>() || end &gt; s.</span><span style="color:#96b5b4;">len</span><span>() || start &gt; end {
</span><span>        </span><span style="color:#b48ead;">return </span><span>Err(&quot;</span><span style="color:#a3be8c;">Invalid slice bounds</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Check that we&#39;re on character boundaries
</span><span>    </span><span style="color:#b48ead;">if </span><span>!s.</span><span style="color:#96b5b4;">is_char_boundary</span><span>(start) || !s.</span><span style="color:#96b5b4;">is_char_boundary</span><span>(end) {
</span><span>        </span><span style="color:#b48ead;">return </span><span>Err(&quot;</span><span style="color:#a3be8c;">Slice bounds not on character boundaries</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    Ok(&amp;s[start..end])
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">parse_utf8_safely</span><span>(</span><span style="color:#bf616a;">bytes</span><span>: &amp;[</span><span style="color:#b48ead;">u8</span><span>]) -&gt; Result {
</span><span>    std::str::from_utf8(bytes)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello, 🦀 world!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">safe_slice</span><span>(text, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5</span><span>) {
</span><span>        Ok(slice) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Safe slice: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, slice),
</span><span>        Err(e) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Error: </span><span style="color:#d08770;">{}</span><span>&quot;, e),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// This would error due to character boundary
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">safe_slice</span><span>(text, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">8</span><span>) {  </span><span style="color:#a7adba;">// Cuts through emoji
</span><span>        Ok(slice) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Safe slice: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, slice),
</span><span>        Err(e) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Error: </span><span style="color:#d08770;">{}</span><span>&quot;, e),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> bytes = </span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">parse_utf8_safely</span><span>(bytes) {
</span><span>        Ok(s) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Valid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, s),
</span><span>        Err(e) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Invalid UTF-8: </span><span style="color:#d08770;">{}</span><span>&quot;, e),
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="performance-optimization">Performance Optimization</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Efficient string processing with slices
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">count_words_in_lines</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec {
</span><span>    text.</span><span style="color:#96b5b4;">lines</span><span>()                    </span><span style="color:#a7adba;">// Iterator over &amp;str
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">line</span><span>| {
</span><span>            line.</span><span style="color:#96b5b4;">split_whitespace</span><span>() </span><span style="color:#a7adba;">// Iterator over &amp;str
</span><span>                .</span><span style="color:#96b5b4;">count</span><span>()            </span><span style="color:#a7adba;">// Count without allocation
</span><span>        })
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()                  </span><span style="color:#a7adba;">// Only collect the counts
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Efficient filtering with slices
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">filter_long_words</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">min_length</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Vec {
</span><span>    text.</span><span style="color:#96b5b4;">split_whitespace</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">filter</span><span>(|</span><span style="color:#bf616a;">word</span><span>| word.</span><span style="color:#96b5b4;">len</span><span>() &gt;= min_length)
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Efficient text transformation
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_csv_line</span><span>(</span><span style="color:#bf616a;">line</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec {
</span><span>    line.</span><span style="color:#96b5b4;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">field</span><span>| field.</span><span style="color:#96b5b4;">trim</span><span>())
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello world</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">Rust programming</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">String slices are efficient</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> word_counts = </span><span style="color:#96b5b4;">count_words_in_lines</span><span>(text);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Word counts per line: </span><span style="color:#d08770;">{:?}</span><span>&quot;, word_counts);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> long_words = </span><span style="color:#96b5b4;">filter_long_words</span><span>(text, </span><span style="color:#d08770;">5</span><span>);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Long words: </span><span style="color:#d08770;">{:?}</span><span>&quot;, long_words);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> csv = &quot;</span><span style="color:#a3be8c;">name, age, city, country</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> fields = </span><span style="color:#96b5b4;">process_csv_line</span><span>(csv);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">CSV fields: </span><span style="color:#d08770;">{:?}</span><span>&quot;, fields);
</span><span>}
</span></code></pre>
<h2 id="common-pitfalls-and-solutions">Common Pitfalls and Solutions</h2>
<h3 id="string-indexing-panics">String Indexing Panics</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> text = &quot;</span><span style="color:#a3be8c;">Hello, 🦀!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Dangerous - can panic on invalid boundaries
</span><span>    </span><span style="color:#a7adba;">// let slice = &amp;text[0..8];  // Panic: not a char boundary
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe alternatives
</span><span>
</span><span>    </span><span style="color:#a7adba;">// 1. Use character-based operations
</span><span>    </span><span style="color:#b48ead;">let</span><span> first_n_chars: String = text.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">7</span><span>).</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">First 7 chars: </span><span style="color:#d08770;">{}</span><span>&quot;, first_n_chars);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// 2. Check boundaries
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">safe_slice_to</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">end</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span>{
</span><span>        </span><span style="color:#b48ead;">if</span><span> end  </span><span style="color:#d08770;">0 </span><span>&amp;&amp; !s.</span><span style="color:#96b5b4;">is_char_boundary</span><span>(valid_end) {
</span><span>                valid_end -= </span><span style="color:#d08770;">1</span><span>;
</span><span>            }
</span><span>            &amp;s[..valid_end]
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> safe = </span><span style="color:#96b5b4;">safe_slice_to</span><span>(text, </span><span style="color:#d08770;">8</span><span>);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Safe slice: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, safe);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// 3. Use get() for bounds checking
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(slice) = text.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">7</span><span>) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Get slice: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, slice);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="lifetime-issues-with-string-slices">Lifetime Issues with String Slices</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// This won&#39;t compile - returning reference to local data
</span><span style="color:#a7adba;">// fn create_slice() -&gt; &amp;str {
</span><span style="color:#a7adba;">//     let s = String::from(&quot;local&quot;);
</span><span style="color:#a7adba;">//     &amp;s[..]  // Error: s dropped at end of function
</span><span style="color:#a7adba;">// }
</span><span>
</span><span style="color:#a7adba;">// Solutions:
</span><span>
</span><span style="color:#a7adba;">// 1. Return owned String
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_owned</span><span>() -&gt; String {
</span><span>    String::from(&quot;</span><span style="color:#a3be8c;">owned</span><span>&quot;)
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// 2. Use string literals for static data
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_static_slice</span><span>() -&gt; &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>{
</span><span>    &quot;</span><span style="color:#a3be8c;">static data</span><span>&quot;
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// 3. Accept and return slices with same lifetime
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_slice</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span>{
</span><span>    input.</span><span style="color:#96b5b4;">trim</span><span>()  </span><span style="color:#a7adba;">// Returns slice with same lifetime as input
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> owned = </span><span style="color:#96b5b4;">create_owned</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> static_slice = </span><span style="color:#96b5b4;">get_static_slice</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> processed = </span><span style="color:#96b5b4;">process_slice</span><span>(&quot;</span><span style="color:#a3be8c;">  hello  </span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Owned: </span><span style="color:#d08770;">{}</span><span>&quot;, owned);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Static: </span><span style="color:#d08770;">{}</span><span>&quot;, static_slice);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Processed: &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, processed);
</span><span>}
</span></code></pre>
<h3 id="mixing-string-and-str">Mixing String and &amp;str</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#a7adba;">// Problem: inefficient mixing of String and &amp;str
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">inefficient_concat</span><span>(</span><span style="color:#bf616a;">parts</span><span>: Vec) -&gt; String {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> result = String::new();
</span><span>        </span><span style="color:#b48ead;">for</span><span> part in parts {
</span><span>            result = result + part;  </span><span style="color:#a7adba;">// Creates new String each time
</span><span>        }
</span><span>        result
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Solution: use efficient string building
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">efficient_concat</span><span>(</span><span style="color:#bf616a;">parts</span><span>: &amp;[&amp;</span><span style="color:#b48ead;">str</span><span>]) -&gt; String {
</span><span>        parts.</span><span style="color:#96b5b4;">join</span><span>(&quot;&quot;)  </span><span style="color:#a7adba;">// Single allocation
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Or use format! for simple cases
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">format_name</span><span>(</span><span style="color:#bf616a;">first</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">last</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; String {
</span><span>        format!(&quot;</span><span style="color:#d08770;">{} {}</span><span>&quot;, first, last)  </span><span style="color:#a7adba;">// Efficient formatting
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> parts = vec![&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">, </span><span>&quot;, &quot;</span><span style="color:#a3be8c;">world</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">!</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">let</span><span> result1 = </span><span style="color:#96b5b4;">inefficient_concat</span><span>(parts.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>    </span><span style="color:#b48ead;">let</span><span> result2 = </span><span style="color:#96b5b4;">efficient_concat</span><span>(&amp;parts);
</span><span>    </span><span style="color:#b48ead;">let</span><span> name = </span><span style="color:#96b5b4;">format_name</span><span>(&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Smith</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Result 1: </span><span style="color:#d08770;">{}</span><span>&quot;, result1);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Result 2: </span><span style="color:#d08770;">{}</span><span>&quot;, result2);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Name: </span><span style="color:#d08770;">{}</span><span>&quot;, name);
</span><span>}
</span></code></pre>
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<h3 id="core-concepts"><strong>Core Concepts</strong></h3>
<p><strong>String slices</strong> (<code>&amp;str</code>) provide:</p>
<ul>
<li><strong>Immutable references</strong> to UTF-8 encoded text data</li>
<li><strong>Zero-cost abstractions</strong> with no heap allocation</li>
<li><strong>Flexible data sources</strong> - can reference literals, heap data, or other sources</li>
<li><strong>Memory safety</strong> through Rust's borrowing system</li>
</ul>
<h3 id="key-characteristics"><strong>Key Characteristics</strong></h3>
<ul>
<li><strong>Fat pointer</strong> containing pointer and length</li>
<li><strong>UTF-8 guarantees</strong> ensure valid Unicode text</li>
<li><strong>Byte-indexed</strong> but must respect character boundaries</li>
<li><strong>Lifetime-dependent</strong> on the data they reference</li>
</ul>
<h3 id="best-practices"><strong>Best Practices</strong></h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Good: Accept &amp;str for flexibility
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process</span><span>(</span><span style="color:#bf616a;">text</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; </span><span style="color:#b48ead;">usize </span><span>{ text.</span><span style="color:#96b5b4;">len</span><span>() }
</span><span>
</span><span style="color:#a7adba;">// Good: Return &amp;str when referencing input
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_extension</span><span>(</span><span style="color:#bf616a;">filename</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Option {
</span><span>    filename.</span><span style="color:#96b5b4;">rfind</span><span>(&#39;</span><span style="color:#a3be8c;">.</span><span>&#39;).</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">pos</span><span>| &amp;filename[pos + </span><span style="color:#d08770;">1</span><span>..])
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Good: Return String when creating new data
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_greeting</span><span>(</span><span style="color:#bf616a;">name</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; String {
</span><span>    format!(&quot;</span><span style="color:#a3be8c;">Hello, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span>&quot;, name)
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Avoid: Unnecessary String parameters
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">less_flexible</span><span>(</span><span style="color:#bf616a;">text</span><span>: String) -&gt; </span><span style="color:#b48ead;">usize </span><span>{ text.</span><span style="color:#96b5b4;">len</span><span>() }
</span></code></pre>
<h3 id="performance-benefits"><strong>Performance Benefits</strong></h3>
<ul>
<li><strong>Zero-copy operations</strong> for most string processing</li>
<li><strong>Memory efficiency</strong> - no unnecessary allocations</li>
<li><strong>Cache-friendly</strong> - contiguous memory access</li>
<li><strong>Optimal for parsing</strong> and text analysis tasks</li>
</ul>
<h3 id="memory-safety-guarantees"><strong>Memory Safety Guarantees</strong></h3>
<ul>
<li><strong>No buffer overflows</strong> - bounds checking prevents out-of-bounds access</li>
<li><strong>No dangling pointers</strong> - lifetime system ensures valid references</li>
<li><strong>UTF-8 validation</strong> - guarantees valid Unicode text</li>
<li><strong>Thread-safe sharing</strong> - immutable data can be safely shared</li>
</ul>
<p>Understanding string slices is fundamental to effective Rust programming. <strong>They enable efficient, safe text processing while maintaining zero-cost abstractions</strong>. Use string slices for most text processing tasks, and convert to owned <code>String</code> only when you need to modify the data or transfer ownership. The combination of performance, safety, and expressiveness makes string slices one of Rust's most powerful features for text manipulation.</p>

    
        </div>

    </article>
</main>


    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/elasticlunr.min.js" defer></script>
    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/search_index.en.js" defer></script>
<script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/js.js" defer></script>

</body>
</html>
