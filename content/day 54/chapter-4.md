---
title: "include! Macro"
description: "Explore the include! macro for embedding external Rust code directly into your project."
date: 2025-10-08
weight: 4
---

# The `include!` Macro in Rust: A Beginner's Guide

Understanding the `include!` macro in Rust is like discovering a way to **photocopy a specific recipe card from another cookbook and paste it directly into your current one**. It's a tool that allows you to take code written in an external file and embed it directly into your Rust program at the exact location of the macro call. This is done at compile time, as if you had manually copied and pasted the code yourself.

## The Professional Kitchen Recipe Analogy ðŸ½ï¸

### Imagine You're a Chef Compiling a New Cookbook

- **Your Rust Program**: Your new, main cookbook (`main.rs`).
- **An External File**: A separate, single recipe card (`dish_steps.rs`) that contains a specific set of instructions.
- **The `include!` Macro**: A special instruction in your main cookbook that says, "At this exact spot, insert the contents of the `dish_steps.rs` recipe card."

**The Problem**: You have a very complex set of preparation steps for a signature sauce that you use in many different recipes. You could copy and paste these steps into every recipe, but that's repetitive and hard to maintain.

**The `include!` Solution**: You write the sauce preparation steps in a single file, `signature_sauce.in`. Then, in each main recipe, you simply write `include!("signature_sauce.in")`.

This way, the steps are defined in one place, but they become a literal part of each recipe that includes them.

## How the `include!` Macro Works

The `include!` macro is a simple yet powerful tool provided by Rust's standard library. It performs a single action:

1. It reads the entire contents of the specified file.
2. It parses that content as Rust code (either an expression or an item, depending on the context).
3. It inserts the parsed code directly into the location where the `include!` macro was called.[^1]

**Key Characteristics**:

- **Compile-Time Operation**: The file inclusion happens during compilation. The final binary has no knowledge of the external file; the code is fully embedded.
- **Path is Relative**: The file path is relative to the file where the `include!` macro is used.[^1]
- **Hygienic vs. Unhygienic**: `include!` is **unhygienic**. This is a crucial concept. It means that the included code behaves as if it were written directly in the parent file. It can access variables, functions, and modules from the parent file, and the parent file can access items defined in the included code. This can be both powerful and dangerous.[^1]


## When to Use `include!` (and When Not To)

The official Rust documentation is very clear: **`include!` is probably not what you are looking for if you are building a multi-file Rust project.** For organizing code into multiple files, you should almost always use Rust's **module system** (`mod my_module;`).[^1]

So, when is `include!` the right tool? It has two primary, specialized use cases:

### Use Case 1: Including Code Generated by a Build Script

This is the most common and idiomatic use of `include!`. Sometimes, you need to generate Rust code as part of your build process. For example, you might have a build script (`build.rs`) that converts a data file (like a CSV or a protocol definition) into a Rust data structure.

**Scenario**: You have a `build.rs` script that generates a large, static `match` statement from a data file and saves it to `src/generated_match.rs`.

**`build.rs` (Conceptual)**

```rust
// This script runs before your main code compiles.
// It would generate a file like `src/generated_match.rs`
// containing:
//
// match input {
//     "A" => 1,
//     "B" => 2,
//     // ... and so on for thousands of entries
//     _ => 0,
// }
```

**`src/main.rs`**

```rust
fn get_code_for_letter(input: &str) -> i32 {
    // Instead of having a massive, unreadable match statement here,
    // we include it from the generated file.
    let result = include!("generated_match.rs");
    result
}

fn main() {
    // This will effectively run the code from the generated file.
    println!("Code for 'A': {}", get_code_for_letter("A"));
}
```

This keeps your main source code clean and separates the generated code from your handwritten logic.

### Use Case 2: Embedding External Documentation or Examples

Sometimes, you might want to keep large documentation examples in separate files to keep your main source file tidy. `include!` can be used for this, but it's important to remember that the included file **must contain valid Rust syntax**.[^1]

**Scenario**: You have a complex example for a function that you want to keep in a separate file.

**`src/my_function_example.rs`**

```rust
// This file contains a valid Rust expression.
let mut numbers = vec![1, 2, 3];
numbers.push(4);
assert_eq!(numbers, vec![1, 2, 3, 4]);
println!("Example ran successfully!");
```

**`src/main.rs`**

```rust
/// My amazing function does amazing things.
///
/// # Examples
///
/// ```
/// // The code from the external file will be inserted here by rustdoc.
include!("my_function_example.rs");
/// ```
fn my_amazing_function() {
    // ... function logic ...
}

fn main() {
    my_amazing_function();
}
```

When you run `cargo doc`, `rustdoc` will execute the `include!` macro and place the content of `my_function_example.rs` into the documentation, where it will be compiled and run as a doc test.

**Note**: For including plain text or Markdown, the `include_str!` macro is often a better choice for documentation (e.g., `#[doc = include_str!("my_docs.md")]`).[^1]

## A Complete Example

Let's walk through a simple, runnable example.

**Project Structure:**

```
.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â”œâ”€â”€ main.rs
    â””â”€â”€ monkeys.in
```

**File: `src/monkeys.in`**
This file contains a Rust expression. It's not a full `.rs` file; it's just a snippet of code.

```rust
['ðŸ™ˆ', 'ðŸ™Š', 'ðŸ™‰']
    .iter()
    .cycle()
    .take(6)
    .collect::<String>()
```

**File: `src/main.rs`**

```rust
fn main() {
    // The `include!` macro will read the content of `monkeys.in`,
    // parse it as a Rust expression, and insert it here.
    let my_string: String = include!("monkeys.in");

    // The line above becomes equivalent to:
    // let my_string: String = ['ðŸ™ˆ', 'ðŸ™Š', 'ðŸ™‰']
    //     .iter()
    //     .cycle()
    //     .take(6)
    //     .collect::<String>();

    assert_eq!("ðŸ™ˆðŸ™ŠðŸ™‰ðŸ™ˆðŸ™ŠðŸ™‰", my_string);
    println!("The monkeys are: {}", my_string);
}
```

**Running the project:**

```bash
cargo run
```

**Output:**

```
The monkeys are: ðŸ™ˆðŸ™ŠðŸ™‰ðŸ™ˆðŸ™ŠðŸ™‰
```

This example clearly shows how the code from `monkeys.in` was seamlessly embedded into `main.rs` and executed.

## `include!` vs. Modules: The Key Difference

It's crucial not to confuse `include!` with the module system (`mod`).


| **Feature** | **`include!` Macro** | **Module System (`mod`)** |
| :-- | :-- | :-- |
| **Mechanism** | **Textual Inclusion (Copy-Paste)**: The code is literally pasted in at compile time. | **Semantic Inclusion**: Creates a new, separate namespace and scope. |
| **Scope \& Privacy** | **Unhygienic**: Included code shares the same scope as the parent file. | **Hygienic**: The module has its own private scope. Items must be made `pub` to be accessible. |
| **Typical Use Case** | Including generated code from `build.rs`. | Organizing a Rust project into logical, maintainable files and components. |
| **File Type** | Can be any file containing a valid Rust expression or item. | Must be a `.rs` file. |
| **When to Choose** | **Almost never** for code organization. **Only** for generated code or special cases. | **Almost always** for splitting your project into multiple files. |

In summary, `include!` is a specialized tool for embedding raw code snippets, primarily from generated sources. For day-to-day code organization, the robust and safe module system is always the correct choice.
<span style="display:none">[^10][^2][^3][^4][^5][^6][^7][^8][^9]</span>

1. https://doc.rust-lang.org/std/macro.include.html
2. https://stackoverflow.com/questions/48033963/how-do-i-add-examples-to-macro-documentation-in-rust
3. https://doc.rust-lang.org/reference/macros-by-example.html
4. https://amanjeev.com/blog/rust-document-macro-invocations/
5. https://earthly.dev/blog/rust-macros/
6. https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/documentation.html
7. https://www.reddit.com/r/rust/comments/7n1c30/question_how_do_i_add_examples_to_macro/
8. https://doc.rust-lang.org/book/ch19-06-macros.html
9. https://docs.rs/include-utils
10. https://users.rust-lang.org/t/macro-documentation/75857
