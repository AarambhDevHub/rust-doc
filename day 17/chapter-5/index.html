<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://aarambhdevhub.github.io/rust-doc/main.css">
    <link rel="icon" href="https://www.rust-lang.org/static/images/favicon-16x16.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> Rust Programming Course! | BTreeMap Introduction </title>
</head>
<body>

<main>
    
    <nav>
            <a href="https:&#x2F;&#x2F;aarambhdevhub.github.io&#x2F;rust-doc&#x2F;">
                        <img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="logo"/>
                    </a>
                <!-- -->

            <a href="javascript:void(0);" onclick="burger()" id="mobile" class="ms-Icon--GlobalNavButton"></a>
            <div id="trees">
                <input class="tree-toggle" type="checkbox" id="day-1-introduction"
                           />
                    <label class="tree-toggle-label"
                           for="day-1-introduction">Day 1: Introduction</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-1/">What is Rust and why use it?</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-2/">Installing Rust Toolchain (rustup, cargo)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-3/">Setting up Development (VS Code + Hello World)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-4/">Understanding Cargo Project Structure</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-2-basic-syntax-variables"
                           />
                    <label class="tree-toggle-label"
                           for="day-2-basic-syntax-variables">Day 2: Basic Syntax &amp; Variables</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-1/">Variables and Mutability in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-2/">Data Types in Rust: Integers, Floats, Booleans, and Characters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-3/">Constants vs Variables</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-4/">Understanding Shadowing in Rust: A Practical Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-5/">Basic Input&#x2F;Output</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-3-functions-control-flow"
                           />
                    <label class="tree-toggle-label"
                           for="day-3-functions-control-flow">Day 3: Functions &amp; Control Flow</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-1/">Function Syntax and Parameters in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-2/">Return Values and Expressions vs Statements</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-3/">If&#x2F;Else Statements in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-4/">Match Expressions in Rust: Powerful Pattern Matching</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-5/">Loops in Rust: loop, while, for Explained</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-4-data-types-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-4-data-types-deep-dive">Day 4: Data Types Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-1/">Compound Types (Tuples, Arrays)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-2/">String vs &amp;str in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-3/">Vector Basics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-4/">Type Annotations and Inference in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-5/">Practical Rust Exercises</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-5-practice-review"
                           />
                    <label class="tree-toggle-label"
                           for="day-5-practice-review">Day 5: Practice &amp; Review</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 5/chapter-1/">Day 5: Practice &amp; Review</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-6-ownership-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-6-ownership-fundamentals">Day 6: Ownership Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-1/">Ownership in Rust: A Detailed Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-2/">Stack vs Heap in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-3/">Understanding Ownership in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-4/">Move Semantics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-5/">Copy Trait in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-7-references-borrowing"
                           />
                    <label class="tree-toggle-label"
                           for="day-7-references-borrowing">Day 7: References &amp; Borrowing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-1/">Immutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-2/">Mutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-3/">Borrowing Rules</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-4/">Reference Lifetime Basics</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-5/">Common Borrowing Errors and Solutions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-8-slices"
                           />
                    <label class="tree-toggle-label"
                           for="day-8-slices">Day 8: Slices</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/">String Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-2/">Array Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-3/">Slice Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-4/">Practical Applications</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-5/">Memory Safety Benefits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-9-advanced-ownership"
                           />
                    <label class="tree-toggle-label"
                           for="day-9-advanced-ownership">Day 9: Advanced Ownership</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-1/">Clone Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-2/">Drop Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-3/">RAII Pattern</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-4/">Memory Management Comparison with Other Languages</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-5/">Best Practices (Advanced Ownership)</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-10-ownership-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-10-ownership-practice">Day 10: Ownership Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-1/">Complex Ownership Scenarios</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-2/">Debugging Ownership Errors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-3/">Code Refactoring Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-4/">Group Problem-Solving</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-11-structs-basics"
                           />
                    <label class="tree-toggle-label"
                           for="day-11-structs-basics">Day 11: Structs Basics</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-1/">Defining and Instantiating Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-2/">Field Access and Modification</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-3/">Tuple Structs and Unit Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-4/">Struct Update Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/">Ownership of Struct Data</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-12-methods-associated-functions"
                           />
                    <label class="tree-toggle-label"
                           for="day-12-methods-associated-functions">Day 12: Methods &amp; Associated Functions</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-1/">Implementing Methods with impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-2/">&amp;self, &amp;mut self, and self</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-3/">Associated Functions (like Constructors)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-4/">Multiple impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-5/">Method Chaining</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-13-advanced-struct-concepts"
                           />
                    <label class="tree-toggle-label"
                           for="day-13-advanced-struct-concepts">Day 13: Advanced Struct Concepts</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-1/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-2/">Debug Trait and Custom Formatting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-3/">Builder Pattern Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-4/">Struct Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-5/">Best Practices for Struct Design</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-14-enums-pattern-matching"
                           />
                    <label class="tree-toggle-label"
                           for="day-14-enums-pattern-matching">Day 14: Enums &amp; Pattern Matching</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-1/">Defining Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-2/">Enum Variants with Data</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-3/">Option&lt;T&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-4/">Result&lt;T, E&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-5/">Advanced Match Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-15-practice-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-15-practice-project">Day 15: Practice Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 15/chapter-1/">Building a Simple CLI Calculator in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-16-vectors"
                           />
                    <label class="tree-toggle-label"
                           for="day-16-vectors">Day 16: Vectors</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-1/">Creating and Updating Vectors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-2/">Vector Methods: push, pop, iter</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-3/">Accessing Vector Elements Safely</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-4/">Vector of Different Types with Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-5/">Performance Considerations</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-17-hashmaps-other-collections"
                           checked/>
                    <label class="tree-toggle-label"
                           for="day-17-hashmaps-other-collections">Day 17: HashMaps &amp; Other Collections</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-1/">HashMap Creation and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-2/">Keys and Values Ownership</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-3/">HashMap Methods and Iteration</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-4/">When to Use Different Collections</a>
                            </li>

                            <li class="active">
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/">BTreeMap Introduction</a>
                            </li>

                            
                                    
                                    
                                        <ul id="toc">
                                            <li><a href="
                                                        https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#btreemap-introduction-in-rust-comprehensive-documentation-for-beginners">BTreeMap Introduction in Rust: Comprehensive Documentation for Beginners</a>
                                                    <ul>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#the-organized-restaurant-reservation-system-analogy-date">The Organized Restaurant Reservation System Analogy 📅</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#understanding-btreemap-fundamentals">Understanding BTreeMap Fundamentals</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#core-btreemap-operations-restaurant-management">Core BTreeMap Operations - Restaurant Management</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#btreemap-vs-hashmap-when-to-choose-what">BTreeMap vs HashMap - When to Choose What</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#advanced-btreemap-techniques">Advanced BTreeMap Techniques</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#best-practices-and-common-patterns">Best Practices and Common Patterns</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/#summary-and-key-takeaways">Summary and Key Takeaways</a>
                                                                </li>
                                                            </ul>
                                                    </li>
                                            </ul>
                                    </ul>
                <input class="tree-toggle" type="checkbox" id="day-18-error-handling"
                           />
                    <label class="tree-toggle-label"
                           for="day-18-error-handling">Day 18: Error Handling</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-1/">Panic! and When to Use It</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-2/">Result&lt;T, E&gt; in Depth</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-3/">The ? Operator in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-4/">Creating Custom Error Types in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-5/">Error Propagation Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-19-strings-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-19-strings-deep-dive">Day 19: Strings Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-1/">String vs &amp;str Revisited</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-2/">String Methods and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-5/">Performance Considerations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-3/">UTF-8 and Character Encoding</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-4/">String Concatenation Techniques</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-20-mini-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-20-mini-project">Day 20: Mini Project</label>

                    <ul class="subtree">
                        </ul>
                <input class="tree-toggle" type="checkbox" id="day-21-generic-functions-structs"
                           />
                    <label class="tree-toggle-label"
                           for="day-21-generic-functions-structs">Day 21: Generic Functions &amp; Structs</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-1/">Generic Function Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-2/">Generic Structs and Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-3/">Type Parameters and Constraints</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-4/">Monomorphization Concept</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-5/">Generic Collections</a>
                            </li>

                            </ul>
                </div>
        </nav>
    <article>

        <div id="on_right">
                <span id="search-ico" class="ms-Icon--Search"></span>
            </div>
            <div class="search-container">
                <input id="search" type="search" placeholder="Search as you type...">
                <div class="search-results">
                    <div class="search-results__header"></div>
                    <ul class="search-results__items"></ul>
                </div>
            </div>
        <div id="wrap">
            
        <h1 id="btreemap-introduction-in-rust-comprehensive-documentation-for-beginners">BTreeMap Introduction in Rust: Comprehensive Documentation for Beginners</h1>
<p>Understanding BTreeMap in Rust is like learning to <strong>manage a sophisticated vegetarian restaurant's reservation system that automatically keeps all bookings in perfect chronological order</strong> - you need a data structure that not only stores customer information efficiently but also maintains everything in sorted order for easy browsing, range queries, and systematic processing. Just as a professional restaurant keeps reservations organized by time so staff can see what's coming next and plan accordingly, Rust's BTreeMap maintains your key-value pairs in sorted order, enabling powerful operations like "find all orders between 6 PM and 8 PM" or "get the next three reservations after this time."</p>
<h2 id="the-organized-restaurant-reservation-system-analogy-date">The Organized Restaurant Reservation System Analogy 📅</h2>
<h3 id="imagine-you-re-managing-a-high-end-vegetarian-restaurant-s-perfect-reservation-system">Imagine You're Managing a High-End Vegetarian Restaurant's Perfect Reservation System</h3>
<p><strong>The Problem with Unorganized Storage:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// ❌ HashMap - like keeping reservations in random order
</span><span style="color:#b48ead;">use </span><span>std::collections::HashMap;
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> reservations = HashMap::new();
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Johnson Anniversary Dinner</span><span>&quot;);
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Smith Business Meeting</span><span>&quot;);
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:15</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Davis Family Celebration</span><span>&quot;);
</span><span>
</span><span style="color:#a7adba;">// Problem: When you iterate, you get random order!
</span><span style="color:#b48ead;">for </span><span>(time, details) in &amp;reservations {
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, details); </span><span style="color:#a7adba;">// Random order: 20:15, 18:00, 19:30
</span><span>}
</span></code></pre>
<p><strong>The BTreeMap Solution - Perfect Organization:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// ✅ BTreeMap - like a perfectly organized reservation book
</span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> reservations = BTreeMap::new();
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Johnson Anniversary Dinner</span><span>&quot;);
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Smith Business Meeting</span><span>&quot;);
</span><span>reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:15</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Davis Family Celebration</span><span>&quot;);
</span><span>
</span><span style="color:#a7adba;">// Magic: Always get reservations in time order!
</span><span style="color:#b48ead;">for </span><span>(time, details) in &amp;reservations {
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, details); </span><span style="color:#a7adba;">// Perfect order: 18:00, 19:30, 20:15
</span><span>}
</span></code></pre>
<p><strong>Why BTreeMap is Superior for Ordered Data:</strong></p>
<ul>
<li>📅 <strong>Automatic sorting</strong> - Keys are always in order, no manual sorting needed</li>
<li>🔍 <strong>Range queries</strong> - Find all reservations between two times instantly</li>
<li>📊 <strong>Predictable iteration</strong> - Always iterate in sorted order</li>
<li>⚡ <strong>Efficient operations</strong> - O(log n) for insert, search, and delete</li>
<li>🎯 <strong>Perfect for time-series data</strong> - Timestamps, dates, sequential IDs</li>
</ul>
<h2 id="understanding-btreemap-fundamentals">Understanding BTreeMap Fundamentals</h2>
<h3 id="what-is-a-btreemap">What is a BTreeMap?</h3>
<p>A <strong>BTreeMap</strong> is Rust's ordered key-value collection that uses a B-tree data structure:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_basics</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🌳 BTreeMap Fundamentals - Organized Restaurant Management</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;60}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Think of BTreeMap as a sophisticated filing system that keeps
</span><span>    </span><span style="color:#a7adba;">// everything automatically sorted by key
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> daily_schedule: BTreeMap&lt;String, String&gt; = BTreeMap::new();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">📊 BTreeMap Characteristics:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Ordered storage: Keys are kept in sorted order</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Tree structure: Uses B-tree for efficient operations</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • O(log n) operations: Insert, search, delete all O(log n)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Range queries: Can efficiently query ranges of keys</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Deterministic: Always iterates in the same order</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add restaurant events (notice we add them out of order)
</span><span>    daily_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">09:00</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Staff meeting</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>    daily_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">14:30</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Lunch rush ends</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>    daily_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">11:00</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Restaurant opens</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>    daily_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Dinner service begins</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>    daily_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">22:00</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Kitchen closes</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📅 Daily Schedule (automatically sorted):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, event) in &amp;daily_schedule {
</span><span>        println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, event);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Key Benefits Demonstrated:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Added events in random order</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ BTreeMap automatically sorted them by time</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Perfect for chronological data!</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_basics</span><span>();
</span><span>}
</span></code></pre>
<h3 id="how-btreemap-works-internally">How BTreeMap Works Internally</h3>
<p><strong>The B-tree structure explained:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span style="color:#b48ead;">use </span><span>ordered_float::OrderedFloat;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btree_concept</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🌳 How BTreeMap Works - The Tree Structure</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;55}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// BTreeMap organizes data like a family tree with special rules:
</span><span>    </span><span style="color:#a7adba;">// 1. Keys in each node are sorted
</span><span>    </span><span style="color:#a7adba;">// 2. All data flows from root to leaves in order
</span><span>    </span><span style="color:#a7adba;">// 3. Tree stays balanced for consistent performance
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> restaurant_ratings: BTreeMap&lt;OrderedFloat&lt;</span><span style="color:#b48ead;">f64</span><span>&gt;, &amp;</span><span style="color:#b48ead;">str</span><span>&gt; = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add restaurant ratings (quality scores)
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.2</span><span>), &quot;</span><span style="color:#a3be8c;">Good Italian Place</span><span>&quot;);
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.8</span><span>), &quot;</span><span style="color:#a3be8c;">Amazing Vegan Bistro</span><span>&quot;);
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">3.9</span><span>), &quot;</span><span style="color:#a3be8c;">Decent Coffee Shop</span><span>&quot;);
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.5</span><span>), &quot;</span><span style="color:#a3be8c;">Great Thai Restaurant</span><span>&quot;);
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.9</span><span>), &quot;</span><span style="color:#a3be8c;">Exceptional French Cuisine</span><span>&quot;);
</span><span>    restaurant_ratings.</span><span style="color:#96b5b4;">insert</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.1</span><span>), &quot;</span><span style="color:#a3be8c;">Nice Breakfast Spot</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🏆 Restaurant Ratings (automatically sorted by score):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(rating, name) in &amp;restaurant_ratings {
</span><span>        </span><span style="color:#b48ead;">let</span><span> stars = &quot;</span><span style="color:#a3be8c;">⭐</span><span>&quot;.</span><span style="color:#96b5b4;">repeat</span><span>(rating.</span><span style="color:#d08770;">0.</span><span style="color:#96b5b4;">floor</span><span>() as </span><span style="color:#b48ead;">usize</span><span>);
</span><span>        println!(&quot;   </span><span style="color:#d08770;">{:.1} {}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, rating.</span><span style="color:#d08770;">0</span><span>, stars, name);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Conceptual tree structure visualization
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🌳 Conceptual Tree Structure:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Each &#39;branch&#39; keeps keys sorted</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Tree automatically balances itself</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   All operations follow tree paths = O(log n)</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📐 Visual Tree Concept:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">            [4.5]</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">           /     </span><span style="color:#96b5b4;">\\</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">      [4.1,4.2]  [4.8,4.9]</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">      /   |   |    |   |   </span><span style="color:#96b5b4;">\\</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    3.9  4.1 4.2  4.8 4.9  ...</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   (Each level keeps everything sorted)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Demonstrate tree properties
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">⚡ Tree Properties in Action:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find all highly-rated restaurants (&gt;= 4.5)
</span><span>    </span><span style="color:#b48ead;">let</span><span> high_rated: Vec&lt;_&gt; = restaurant_ratings
</span><span>        .</span><span style="color:#96b5b4;">range</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.5</span><span>)..)
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🌟 High-rated restaurants (&gt;= 4.5 stars):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(rating, name) in high_rated {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">⭐ </span><span style="color:#d08770;">{}</span><span>&quot;, rating.</span><span style="color:#d08770;">0</span><span>, name);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find restaurants in specific range
</span><span>    </span><span style="color:#b48ead;">let</span><span> good_range: Vec&lt;_&gt; = restaurant_ratings
</span><span>        .</span><span style="color:#96b5b4;">range</span><span>(OrderedFloat(</span><span style="color:#d08770;">4.0</span><span>)..OrderedFloat(</span><span style="color:#d08770;">4.5</span><span>))
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   👍 Good restaurants (4.0-4.5 stars):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(rating, name) in good_range {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">⭐ </span><span style="color:#d08770;">{}</span><span>&quot;, rating.</span><span style="color:#d08770;">0</span><span>, name);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btree_concept</span><span>();
</span><span>}
</span></code></pre>
<h2 id="core-btreemap-operations-restaurant-management">Core BTreeMap Operations - Restaurant Management</h2>
<h3 id="1-creating-and-populating-btreemaps">1. Creating and Populating BTreeMaps</h3>
<p><strong>Different ways to create and fill your organized restaurant data:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_creation</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🏗️ BTreeMap Creation - Setting Up Restaurant Systems</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;55}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 1: Empty BTreeMap with new()
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">📋 Method 1: Empty Reservation System</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> reservations: BTreeMap&lt;String, String&gt; = BTreeMap::new();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Created empty reservation system</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 2: From array data (Rust 1.56+)
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🍽️ Method 2: Menu Pricing from Array</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> menu_prices = BTreeMap::from([
</span><span>        (&quot;</span><span style="color:#a3be8c;">Appetizer</span><span>&quot;, </span><span style="color:#d08770;">8.99</span><span>),
</span><span>        (&quot;</span><span style="color:#a3be8c;">Main Course</span><span>&quot;, </span><span style="color:#d08770;">15.99</span><span>),
</span><span>        (&quot;</span><span style="color:#a3be8c;">Dessert</span><span>&quot;, </span><span style="color:#d08770;">6.99</span><span>),
</span><span>        (&quot;</span><span style="color:#a3be8c;">Beverage</span><span>&quot;, </span><span style="color:#d08770;">3.99</span><span>),
</span><span>    ]);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📊 Menu prices in alphabetical order:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(category, price) in &amp;menu_prices {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span>&quot;, category, price);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 3: From iterator (converting from other collections)
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📅 Method 3: Time Slots from Vector</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> time_slots = vec![
</span><span>        (&quot;</span><span style="color:#a3be8c;">20:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Late dinner</span><span>&quot;),
</span><span>        (&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Early dinner</span><span>&quot;),
</span><span>        (&quot;</span><span style="color:#a3be8c;">19:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Prime time</span><span>&quot;),
</span><span>        (&quot;</span><span style="color:#a3be8c;">21:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Last seating</span><span>&quot;),
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> organized_slots: BTreeMap&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>&gt; = time_slots
</span><span>        .</span><span style="color:#96b5b4;">into_iter</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ⏰ Time slots in chronological order:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, description) in &amp;organized_slots {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, description);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 4: Building with insert operations
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Method 4: Customer Loyalty Tiers</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> loyalty_tiers = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Insert in random order - BTreeMap will sort automatically
</span><span>    loyalty_tiers.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1000</span><span>, &quot;</span><span style="color:#a3be8c;">Platinum Member</span><span>&quot;);
</span><span>    loyalty_tiers.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">100</span><span>, &quot;</span><span style="color:#a3be8c;">Bronze Member</span><span>&quot;);
</span><span>    loyalty_tiers.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">500</span><span>, &quot;</span><span style="color:#a3be8c;">Gold Member</span><span>&quot;);
</span><span>    loyalty_tiers.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">250</span><span>, &quot;</span><span style="color:#a3be8c;">Silver Member</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🏆 Loyalty tiers by points required:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(points, tier) in &amp;loyalty_tiers {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> points → </span><span style="color:#d08770;">{}</span><span>&quot;, points, tier);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 5: Complex structured data
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🏢 Method 5: Comprehensive Restaurant Analytics</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>DailyMetrics {
</span><span>        </span><span style="color:#bf616a;">revenue</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>        </span><span style="color:#bf616a;">customer_count</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>        </span><span style="color:#bf616a;">avg_satisfaction</span><span>: </span><span style="color:#b48ead;">f32</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> daily_analytics = BTreeMap::new();
</span><span>
</span><span>    daily_analytics.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-10</span><span>&quot;, DailyMetrics {
</span><span>        revenue: </span><span style="color:#d08770;">2847.50</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">89</span><span>,
</span><span>        avg_satisfaction: </span><span style="color:#d08770;">4.6</span><span>,
</span><span>    });
</span><span>
</span><span>    daily_analytics.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-08</span><span>&quot;, DailyMetrics {
</span><span>        revenue: </span><span style="color:#d08770;">2234.75</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">67</span><span>,
</span><span>        avg_satisfaction: </span><span style="color:#d08770;">4.4</span><span>,
</span><span>    });
</span><span>
</span><span>    daily_analytics.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-09</span><span>&quot;, DailyMetrics {
</span><span>        revenue: </span><span style="color:#d08770;">2653.20</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">78</span><span>,
</span><span>        avg_satisfaction: </span><span style="color:#d08770;">4.7</span><span>,
</span><span>    });
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📈 Daily analytics in chronological order:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(date, metrics) in &amp;daily_analytics {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;"> revenue, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> customers, </span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">⭐</span><span>&quot;,
</span><span>                 date, metrics.revenue, metrics.customer_count, metrics.avg_satisfaction);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">✨ Creation Methods Summary:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ BTreeMap::new() - Start empty</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ BTreeMap::from([...]) - From array data</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ collect() from iterator - Convert collections</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Manual insert() - Build step by step</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ All methods automatically maintain sorted order!</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_creation</span><span>();
</span><span>}
</span></code></pre>
<h3 id="2-accessing-and-querying-data">2. Accessing and Querying Data</h3>
<p><strong>Efficient data retrieval in your organized system:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_access</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🔍 BTreeMap Data Access - Restaurant Information Queries</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;60}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Setup restaurant event schedule
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> event_schedule = BTreeMap::new();
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">08:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Staff arrival</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">10:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Prep kitchen</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">11:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Restaurant opens</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">12:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Lunch service</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">14:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Lunch service ends</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">17:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Dinner prep</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Dinner service</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">22:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Last orders</span><span>&quot;);
</span><span>    event_schedule.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">23:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Restaurant closes</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 1: get() - Safe single item access
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🎯 Method 1: Single Event Lookup (get)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> check_times = [&quot;</span><span style="color:#a3be8c;">12:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">15:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">for</span><span> time in check_times {
</span><span>        </span><span style="color:#b48ead;">match</span><span> event_schedule.</span><span style="color:#96b5b4;">get</span><span>(time) {
</span><span>            Some(event) =&gt; println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → ✅ </span><span style="color:#d08770;">{}</span><span>&quot;, time, event),
</span><span>            None =&gt; println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → ❌ No scheduled event</span><span>&quot;, time),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 2: contains_key() - Check existence
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">❓ Method 2: Event Existence Check</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> important_times = [&quot;</span><span style="color:#a3be8c;">11:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">16:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">22:00</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">for</span><span> time in important_times {
</span><span>        </span><span style="color:#b48ead;">if</span><span> event_schedule.</span><span style="color:#96b5b4;">contains_key</span><span>(time) {
</span><span>            println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → ✅ Event scheduled</span><span>&quot;, time);
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → ⏰ Free time slot</span><span>&quot;, time);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 3: first_key_value() and last_key_value() - Boundaries
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📊 Method 3: Day Boundaries</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some((first_time, first_event)) = event_schedule.</span><span style="color:#96b5b4;">first_key_value</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   🌅 Day starts: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> with &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, first_time, first_event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some((last_time, last_event)) = event_schedule.</span><span style="color:#96b5b4;">last_key_value</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   🌙 Day ends: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> with &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, last_time, last_event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 4: range() - The killer feature!
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🔍 Method 4: Range Queries (BTreeMap&#39;s Superpower!)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find all events during lunch period
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🥗 Lunch period events (12:00 - 15:00):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, event) in event_schedule.</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">12:00</span><span>&quot;..&quot;</span><span style="color:#a3be8c;">15:00</span><span>&quot;) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find all events after 18:00
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🌆 Evening events (18:00 onwards):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, event) in event_schedule.</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;..) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find all events before noon
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🌅 Morning events (before 12:00):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, event) in event_schedule.</span><span style="color:#96b5b4;">range</span><span>(..&quot;</span><span style="color:#a3be8c;">12:00</span><span>&quot;) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 5: Advanced range queries with complex data
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📈 Method 5: Advanced Range Queries</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> order_queue = BTreeMap::new();
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1</span><span>, &quot;</span><span style="color:#a3be8c;">Order #001 - Quinoa Bowl</span><span>&quot;);
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">3</span><span>, &quot;</span><span style="color:#a3be8c;">Order #003 - Veggie Burger</span><span>&quot;);
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">5</span><span>, &quot;</span><span style="color:#a3be8c;">Order #005 - Lentil Soup</span><span>&quot;);
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">7</span><span>, &quot;</span><span style="color:#a3be8c;">Order #007 - Mediterranean Wrap</span><span>&quot;);
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">9</span><span>, &quot;</span><span style="color:#a3be8c;">Order #009 - Green Salad</span><span>&quot;);
</span><span>    order_queue.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">12</span><span>, &quot;</span><span style="color:#a3be8c;">Order #012 - Pasta Primavera</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Process next 3 orders (range query + take)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   👨‍🍳 Next 3 orders to prepare:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(order_num, details) in order_queue.</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>..).</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">3</span><span>) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Order </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, order_num, details);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find orders in middle range
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📋 Orders 5-10:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(order_num, details) in order_queue.</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">5</span><span>..=</span><span style="color:#d08770;">10</span><span>) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Order </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, order_num, details);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 6: Getting adjacent items
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🔗 Method 6: Finding Adjacent Events</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> current_time = &quot;</span><span style="color:#a3be8c;">16:00</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find next event after current time
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some((next_time, next_event)) = event_schedule.</span><span style="color:#96b5b4;">range</span><span>(current_time..).</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   ⏭️ Next event after </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, current_time, next_time, next_event);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find previous event before current time
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some((prev_time, prev_event)) = event_schedule.</span><span style="color:#96b5b4;">range</span><span>(..current_time).</span><span style="color:#96b5b4;">last</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   ⏮️ Previous event before </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, current_time, prev_time, prev_event);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 BTreeMap Access Superpowers:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ O(log n) single item access</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Efficient range queries (impossible with HashMap!)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Easy boundary access (first/last)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Natural adjacent item finding</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Perfect for time-series and ordered data</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_access</span><span>();
</span><span>}
</span></code></pre>
<h3 id="3-modification-and-updates">3. Modification and Updates</h3>
<p><strong>Safely updating your organized restaurant data:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_modification</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">✏️ BTreeMap Modifications - Restaurant System Updates</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;55}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Setup table capacity management
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> table_capacity = BTreeMap::new();
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">8</span><span>);   </span><span style="color:#a7adba;">// 8 tables for 2 people
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">12</span><span>);  </span><span style="color:#a7adba;">// 12 tables for 4 people
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">6</span><span>);   </span><span style="color:#a7adba;">// 6 tables for 6 people
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">3</span><span>);   </span><span style="color:#a7adba;">// 3 tables for 8 people
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">2</span><span>);  </span><span style="color:#a7adba;">// 2 tables for 10 people
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">📊 Initial Table Capacity:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(size, count) in &amp;table_capacity {
</span><span>        println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">-person tables: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> available</span><span>&quot;, size, count);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 1: insert() - Add or update
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🔄 Method 1: Table Updates (insert)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add new table size
</span><span>    table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>);  </span><span style="color:#a7adba;">// 4 tables for 3 people
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ➕ Added 3-person tables: 4 available</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Update existing table count
</span><span>    </span><span style="color:#b48ead;">let</span><span> old_count = table_capacity.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">15</span><span>);  </span><span style="color:#a7adba;">// Update 4-person tables
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(previous) = old_count {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   🔄 Updated 4-person tables: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → 15</span><span>&quot;, previous);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 2: get_mut() - Modify existing values
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">✏️ Method 2: In-Place Modifications (get_mut)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Restaurant gets busy - some tables become unavailable
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(count) = table_capacity.</span><span style="color:#96b5b4;">get_mut</span><span>(&amp;</span><span style="color:#d08770;">6</span><span>) {
</span><span>        *count -= </span><span style="color:#d08770;">2</span><span>;  </span><span style="color:#a7adba;">// 2 tables are now occupied
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   📉 6-person tables: 2 tables now occupied, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> available</span><span>&quot;, count);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(count) = table_capacity.</span><span style="color:#96b5b4;">get_mut</span><span>(&amp;</span><span style="color:#d08770;">8</span><span>) {
</span><span>        *count -= </span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#a7adba;">// 1 large table occupied
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   📉 8-person tables: 1 table occupied, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> available</span><span>&quot;, count);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 3: remove() - Remove entries
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🗑️ Method 3: Removing Table Types (remove)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Remove 10-person tables (converted to storage)
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(removed_count) = table_capacity.</span><span style="color:#96b5b4;">remove</span><span>(&amp;</span><span style="color:#d08770;">10</span><span>) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   ➖ Removed 10-person tables: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> tables converted to storage</span><span>&quot;, removed_count);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 4: Entry API for conditional operations
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Method 4: Smart Table Management (Entry API)</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add tables or update existing counts
</span><span>    *table_capacity.</span><span style="color:#96b5b4;">entry</span><span>(</span><span style="color:#d08770;">12</span><span>).</span><span style="color:#96b5b4;">or_insert</span><span>(</span><span style="color:#d08770;">0</span><span>) += </span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#a7adba;">// Add 1 private dining room
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🆕 Added private dining room (12-person): 1 available</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Conditional update based on current value
</span><span>    table_capacity.</span><span style="color:#96b5b4;">entry</span><span>(</span><span style="color:#d08770;">2</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">and_modify</span><span>(|</span><span style="color:#bf616a;">count</span><span>| *count += </span><span style="color:#d08770;">3</span><span>)  </span><span style="color:#a7adba;">// Add 3 more 2-person tables
</span><span>        .</span><span style="color:#96b5b4;">or_insert</span><span>(</span><span style="color:#d08770;">3</span><span>);  </span><span style="color:#a7adba;">// Or start with 3 if none existed
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ➕ Added 3 more 2-person tables</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 5: Bulk modifications
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📦 Method 5: Bulk Table Adjustments</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Weekend rush - temporarily reduce available tables
</span><span>    </span><span style="color:#b48ead;">let</span><span> weekend_reservations = [(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">2</span><span>), (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">4</span><span>), (</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">1</span><span>)];  </span><span style="color:#a7adba;">// (table_size, reserved_count)
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(table_size, reserved) in weekend_reservations {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(available) = table_capacity.</span><span style="color:#96b5b4;">get_mut</span><span>(&amp;table_size) {
</span><span>            *available = available.</span><span style="color:#96b5b4;">saturating_sub</span><span>(reserved);
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">   📅 Weekend: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">-person tables, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> reserved, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> available</span><span>&quot;,
</span><span>                     table_size, reserved, available);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method 6: Complex data structure updates
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🏢 Method 6: Complex Restaurant Analytics Updates</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>RestaurantStats {
</span><span>        </span><span style="color:#bf616a;">daily_revenue</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>        </span><span style="color:#bf616a;">customer_count</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>        </span><span style="color:#bf616a;">popular_dish</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">avg_wait_time</span><span>: </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#a7adba;">// minutes
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> weekly_stats = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add initial data
</span><span>    weekly_stats.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">Monday</span><span>&quot;, RestaurantStats {
</span><span>        daily_revenue: </span><span style="color:#d08770;">2450.75</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">87</span><span>,
</span><span>        popular_dish: &quot;</span><span style="color:#a3be8c;">Quinoa Bowl</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        avg_wait_time: </span><span style="color:#d08770;">15</span><span>,
</span><span>    });
</span><span>
</span><span>    weekly_stats.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">Tuesday</span><span>&quot;, RestaurantStats {
</span><span>        daily_revenue: </span><span style="color:#d08770;">2156.40</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">76</span><span>,
</span><span>        popular_dish: &quot;</span><span style="color:#a3be8c;">Veggie Burger</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        avg_wait_time: </span><span style="color:#d08770;">12</span><span>,
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Update Tuesday&#39;s stats (end of day correction)
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(tuesday_stats) = weekly_stats.</span><span style="color:#96b5b4;">get_mut</span><span>(&quot;</span><span style="color:#a3be8c;">Tuesday</span><span>&quot;) {
</span><span>        tuesday_stats.daily_revenue += </span><span style="color:#d08770;">234.50</span><span>;  </span><span style="color:#a7adba;">// Late orders came in
</span><span>        tuesday_stats.customer_count += </span><span style="color:#d08770;">8</span><span>;       </span><span style="color:#a7adba;">// Additional customers
</span><span>        tuesday_stats.avg_wait_time = </span><span style="color:#d08770;">10</span><span>;        </span><span style="color:#a7adba;">// Improved efficiency
</span><span>
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   📊 Tuesday stats updated: $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;"> revenue, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> customers</span><span>&quot;,
</span><span>                 tuesday_stats.daily_revenue, tuesday_stats.customer_count);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add Wednesday data
</span><span>    weekly_stats.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">Wednesday</span><span>&quot;, RestaurantStats {
</span><span>        daily_revenue: </span><span style="color:#d08770;">2789.60</span><span>,
</span><span>        customer_count: </span><span style="color:#d08770;">94</span><span>,
</span><span>        popular_dish: &quot;</span><span style="color:#a3be8c;">Mediterranean Wrap</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        avg_wait_time: </span><span style="color:#d08770;">8</span><span>,
</span><span>    });
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📈 Current Table Availability (sorted by table size):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(size, count) in &amp;table_capacity {
</span><span>        </span><span style="color:#b48ead;">let</span><span> status = </span><span style="color:#b48ead;">if </span><span>*count &gt; </span><span style="color:#d08770;">5 </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">✅ Good availability</span><span>&quot;
</span><span>        } </span><span style="color:#b48ead;">else if </span><span>*count &gt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">⚠️ Limited availability</span><span>&quot;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">❌ Fully booked</span><span>&quot;
</span><span>        };
</span><span>
</span><span>        println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">-person tables: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> available </span><span style="color:#d08770;">{}</span><span>&quot;, size, count, status);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📊 Weekly Performance (chronological order):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(day, stats) in &amp;weekly_stats {
</span><span>        println!(&quot;   </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> customers, avg wait: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">min</span><span>&quot;,
</span><span>                 day, stats.daily_revenue, stats.customer_count, stats.avg_wait_time);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_modification</span><span>();
</span><span>}
</span></code></pre>
<h2 id="btreemap-vs-hashmap-when-to-choose-what">BTreeMap vs HashMap - When to Choose What</h2>
<h3 id="understanding-the-trade-offs">Understanding the Trade-offs</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_vs_hashmap</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">⚖️ BTreeMap vs HashMap - Choosing the Right Tool</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;55}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::{BTreeMap, HashMap};
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::time::Instant;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Scenario comparison
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🎯 Scenario-Based Comparison:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Scenario 1: Random access performance
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">⚡ Scenario 1: Random Access Performance</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> hashmap = HashMap::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> btreemap = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Add the same data to both
</span><span>    </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">1000 </span><span>{
</span><span>        </span><span style="color:#b48ead;">let</span><span> key = format!(&quot;</span><span style="color:#a3be8c;">customer_</span><span style="color:#d08770;">{:04}</span><span>&quot;, i);
</span><span>        </span><span style="color:#b48ead;">let</span><span> value = format!(&quot;</span><span style="color:#a3be8c;">Customer data </span><span style="color:#d08770;">{}</span><span>&quot;, i);
</span><span>        hashmap.</span><span style="color:#96b5b4;">insert</span><span>(key.</span><span style="color:#96b5b4;">clone</span><span>(), value.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>        btreemap.</span><span style="color:#96b5b4;">insert</span><span>(key, value);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Test random access
</span><span>    </span><span style="color:#b48ead;">let</span><span> test_key = &quot;</span><span style="color:#a3be8c;">customer_0500</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = Instant::now();
</span><span>    </span><span style="color:#b48ead;">let</span><span> _result = hashmap.</span><span style="color:#96b5b4;">get</span><span>(test_key);
</span><span>    </span><span style="color:#b48ead;">let</span><span> hashmap_time = start.</span><span style="color:#96b5b4;">elapsed</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = Instant::now();
</span><span>    </span><span style="color:#b48ead;">let</span><span> _result = btreemap.</span><span style="color:#96b5b4;">get</span><span>(test_key);
</span><span>    </span><span style="color:#b48ead;">let</span><span> btreemap_time = start.</span><span style="color:#96b5b4;">elapsed</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   HashMap lookup: </span><span style="color:#d08770;">{:?}</span><span>&quot;, hashmap_time);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   BTreeMap lookup: </span><span style="color:#d08770;">{:?}</span><span>&quot;, btreemap_time);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   💡 HashMap is typically faster for single lookups</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Scenario 2: Ordered iteration
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📊 Scenario 2: Ordered Data Processing</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> order_times_hash = HashMap::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> order_times_btree = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> times = [&quot;</span><span style="color:#a3be8c;">14:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">12:15</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">18:45</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">11:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">for</span><span> time in times {
</span><span>        order_times_hash.</span><span style="color:#96b5b4;">insert</span><span>(time, format!(&quot;</span><span style="color:#a3be8c;">Order at </span><span style="color:#d08770;">{}</span><span>&quot;, time));
</span><span>        order_times_btree.</span><span style="color:#96b5b4;">insert</span><span>(time, format!(&quot;</span><span style="color:#a3be8c;">Order at </span><span style="color:#d08770;">{}</span><span>&quot;, time));
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   HashMap iteration (random order):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, order) in order_times_hash.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">3</span><span>) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, order);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   BTreeMap iteration (sorted order):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, order) in order_times_btree.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">3</span><span>) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, order);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ BTreeMap provides guaranteed order</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Scenario 3: Range queries
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🔍 Scenario 3: Range Queries</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> reservation_times = BTreeMap::new();
</span><span>    reservation_times.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">17:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Early dinner</span><span>&quot;);
</span><span>    reservation_times.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Prime time</span><span>&quot;);
</span><span>    reservation_times.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:15</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Peak hours</span><span>&quot;);
</span><span>    reservation_times.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:45</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Late dinner</span><span>&quot;);
</span><span>    reservation_times.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">21:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Last seating</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Range query: evening prime time (18:00 - 20:00)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Prime time reservations (18:00-20:00):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, description) in reservation_times.</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;..&quot;</span><span style="color:#a3be8c;">20:00</span><span>&quot;) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, description);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   💡 HashMap cannot do range queries efficiently!</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Decision matrix
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Decision Matrix:</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">✅ Use HashMap when:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You need fastest possible single-item access</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Order doesn&#39;t matter</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You&#39;re doing lots of lookups/inserts</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • Memory usage is a concern (slightly less overhead)</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">✅ Use BTreeMap when:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You need data in sorted order</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You need range queries</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You want deterministic iteration order</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You&#39;re working with time-series data</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   • You need to find min/max keys efficiently</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📊 Performance Characteristics:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">┌─────────────┬──────────────┬──────────────┐</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Operation   │ HashMap      │ BTreeMap     │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">├─────────────┼──────────────┼──────────────┤</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Insert      │ O(1) avg     │ O(log n)     │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Lookup      │ O(1) avg     │ O(log n)     │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Delete      │ O(1) avg     │ O(log n)     │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Iteration   │ O(n) random  │ O(n) sorted  │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Range Query │ Not possible │ O(log n + k) │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">│ Min/Max     │ O(n)         │ O(log n)     │</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">└─────────────┴──────────────┴──────────────┘</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Real-World Guidelines:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🏪 Customer database → HashMap (fast lookups)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📅 Reservation system → BTreeMap (chronological order)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   💰 Price catalog → HashMap (quick price checks)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📊 Daily reports → BTreeMap (date-ordered)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🎮 Game leaderboard → BTreeMap (score-ordered)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ⚙️ Configuration settings → HashMap (key-value access)</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_vs_hashmap</span><span>();
</span><span>}
</span></code></pre>
<h2 id="advanced-btreemap-techniques">Advanced BTreeMap Techniques</h2>
<h3 id="powerful-operations-for-restaurant-management">Powerful Operations for Restaurant Management</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_advanced_btreemap</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🚀 Advanced BTreeMap Techniques - Pro Restaurant Management</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;65}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Advanced Technique 1: Time-based analytics with ranges
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">📊 Technique 1: Time-Based Analytics</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> hourly_sales = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Sales data throughout the day (hour -&gt; revenue)
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">11</span><span>, </span><span style="color:#d08770;">145.50</span><span>);  </span><span style="color:#a7adba;">// 11 AM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">12</span><span>, </span><span style="color:#d08770;">267.75</span><span>);  </span><span style="color:#a7adba;">// 12 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">13</span><span>, </span><span style="color:#d08770;">298.25</span><span>);  </span><span style="color:#a7adba;">// 1 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">14</span><span>, </span><span style="color:#d08770;">189.50</span><span>);  </span><span style="color:#a7adba;">// 2 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">17</span><span>, </span><span style="color:#d08770;">234.75</span><span>);  </span><span style="color:#a7adba;">// 5 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">18</span><span>, </span><span style="color:#d08770;">456.25</span><span>);  </span><span style="color:#a7adba;">// 6 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">19</span><span>, </span><span style="color:#d08770;">523.80</span><span>);  </span><span style="color:#a7adba;">// 7 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">20</span><span>, </span><span style="color:#d08770;">387.40</span><span>);  </span><span style="color:#a7adba;">// 8 PM
</span><span>    hourly_sales.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">21</span><span>, </span><span style="color:#d08770;">245.30</span><span>);  </span><span style="color:#a7adba;">// 9 PM
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Analyze lunch period (11 AM - 3 PM)
</span><span>    </span><span style="color:#b48ead;">let</span><span> lunch_revenue: </span><span style="color:#b48ead;">f64 </span><span>= hourly_sales
</span><span>        .</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">11</span><span>..=</span><span style="color:#d08770;">14</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|(_, </span><span style="color:#bf616a;">revenue</span><span>)| revenue)
</span><span>        .</span><span style="color:#96b5b4;">sum</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🥗 Lunch period revenue (11 AM - 2 PM): $</span><span style="color:#d08770;">{:.2}</span><span>&quot;, lunch_revenue);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Analyze dinner period (5 PM - 9 PM)
</span><span>    </span><span style="color:#b48ead;">let</span><span> dinner_revenue: </span><span style="color:#b48ead;">f64 </span><span>= hourly_sales
</span><span>        .</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">17</span><span>..=</span><span style="color:#d08770;">21</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|(_, </span><span style="color:#bf616a;">revenue</span><span>)| revenue)
</span><span>        .</span><span style="color:#96b5b4;">sum</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🍽️ Dinner period revenue (5 PM - 9 PM): $</span><span style="color:#d08770;">{:.2}</span><span>&quot;, dinner_revenue);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find peak hour
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some((peak_hour, peak_revenue)) = hourly_sales
</span><span>        .</span><span style="color:#96b5b4;">iter</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">max_by</span><span>(|(_, </span><span style="color:#bf616a;">a</span><span>), (_, </span><span style="color:#bf616a;">b</span><span>)| a.</span><span style="color:#96b5b4;">partial_cmp</span><span>(b).</span><span style="color:#96b5b4;">unwrap</span><span>()) {
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> time_display = </span><span style="color:#b48ead;">if </span><span>*peak_hour &lt;= </span><span style="color:#d08770;">12 </span><span>{
</span><span>            format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> AM</span><span>&quot;, peak_hour)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> PM</span><span>&quot;, peak_hour - </span><span style="color:#d08770;">12</span><span>)
</span><span>        };
</span><span>
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   🏆 Peak hour: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> with $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;"> revenue</span><span>&quot;, time_display, peak_revenue);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Advanced Technique 2: Sliding window analysis
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📈 Technique 2: Sliding Window Analysis</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Calculate 3-hour rolling averages
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> rolling_averages = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(&amp;hour, &amp;revenue) in &amp;hourly_sales {
</span><span>        </span><span style="color:#a7adba;">// Get 3-hour window centered on current hour
</span><span>        </span><span style="color:#b48ead;">let</span><span> window_start = hour.</span><span style="color:#96b5b4;">saturating_sub</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>        </span><span style="color:#b48ead;">let</span><span> window_end = hour + </span><span style="color:#d08770;">2</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> window_sales: Vec&lt;</span><span style="color:#b48ead;">f64</span><span>&gt; = hourly_sales
</span><span>            .</span><span style="color:#96b5b4;">range</span><span>(window_start..window_end)
</span><span>            .</span><span style="color:#96b5b4;">map</span><span>(|(_, </span><span style="color:#bf616a;">revenue</span><span>)| *revenue)
</span><span>            .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> window_sales.</span><span style="color:#96b5b4;">len</span><span>() &gt;= </span><span style="color:#d08770;">2 </span><span>{  </span><span style="color:#a7adba;">// Need at least 2 data points
</span><span>            </span><span style="color:#b48ead;">let</span><span> average = window_sales.</span><span style="color:#96b5b4;">iter</span><span>().sum::&lt;</span><span style="color:#b48ead;">f64</span><span>&gt;() / window_sales.</span><span style="color:#96b5b4;">len</span><span>() as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            rolling_averages.</span><span style="color:#96b5b4;">insert</span><span>(hour, average);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📊 3-hour rolling averages:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(hour, avg) in rolling_averages {
</span><span>        </span><span style="color:#b48ead;">let</span><span> time_display = </span><span style="color:#b48ead;">if</span><span> hour &lt;= </span><span style="color:#d08770;">12 </span><span>{
</span><span>            format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> AM</span><span>&quot;, hour)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> PM</span><span>&quot;, hour - </span><span style="color:#d08770;">12</span><span>)
</span><span>        };
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;"> average</span><span>&quot;, time_display, avg);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Advanced Technique 3: Capacity planning with ranges
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 Technique 3: Smart Capacity Planning</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> table_bookings = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Time slots with booking counts (30-minute intervals)
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">17:00</span><span>&quot;, </span><span style="color:#d08770;">12</span><span>);  </span><span style="color:#a7adba;">// 12 tables booked
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">17:30</span><span>&quot;, </span><span style="color:#d08770;">18</span><span>);
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, </span><span style="color:#d08770;">25</span><span>);  </span><span style="color:#a7adba;">// Peak starts
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:30</span><span>&quot;, </span><span style="color:#d08770;">28</span><span>);
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:00</span><span>&quot;, </span><span style="color:#d08770;">30</span><span>);  </span><span style="color:#a7adba;">// Peak
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;, </span><span style="color:#d08770;">27</span><span>);
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:00</span><span>&quot;, </span><span style="color:#d08770;">22</span><span>);
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:30</span><span>&quot;, </span><span style="color:#d08770;">15</span><span>);
</span><span>    table_bookings.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">21:00</span><span>&quot;, </span><span style="color:#d08770;">8</span><span>);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> total_tables = </span><span style="color:#d08770;">35</span><span>;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find peak period (when capacity &gt; 80%)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🚨 High-capacity periods (&gt;80% full):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, bookings) in &amp;table_bookings {
</span><span>        </span><span style="color:#b48ead;">let</span><span> capacity_percent = (*bookings as </span><span style="color:#b48ead;">f64 </span><span>/ total_tables as </span><span style="color:#b48ead;">f64</span><span>) * </span><span style="color:#d08770;">100.0</span><span>;
</span><span>        </span><span style="color:#b48ead;">if</span><span> capacity_percent &gt; </span><span style="color:#d08770;">80.0 </span><span>{
</span><span>            println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> tables (</span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">% capacity)</span><span>&quot;,
</span><span>                     time, bookings, capacity_percent);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Find available time slots
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Available time slots (&lt;70% capacity):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, bookings) in &amp;table_bookings {
</span><span>        </span><span style="color:#b48ead;">let</span><span> capacity_percent = (*bookings as </span><span style="color:#b48ead;">f64 </span><span>/ total_tables as </span><span style="color:#b48ead;">f64</span><span>) * </span><span style="color:#d08770;">100.0</span><span>;
</span><span>        </span><span style="color:#b48ead;">if</span><span> capacity_percent &lt; </span><span style="color:#d08770;">70.0 </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> available = total_tables - bookings;
</span><span>            println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> tables available (</span><span style="color:#d08770;">{:.1}</span><span style="color:#a3be8c;">% capacity)</span><span>&quot;,
</span><span>                     time, available, capacity_percent);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Advanced Technique 4: Hierarchical data organization
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🏗️ Technique 4: Hierarchical Menu Organization</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Use composite keys for hierarchical data
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> menu_hierarchy = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Key format: &quot;category:subcategory:item&quot;
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">1:Appetizers:Hummus Platter</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">8.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">1:Appetizers:Stuffed Mushrooms</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">9.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2:Main:Quinoa Bowl</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">15.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2:Main:Veggie Burger</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">12.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2:Main:Pasta Primavera</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">14.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">3:Desserts:Chocolate Mousse</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">6.99</span><span>);
</span><span>    menu_hierarchy.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">3:Desserts:Fruit Tart</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">5.99</span><span>);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Display menu by category (automatic grouping due to sorted keys)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📋 Hierarchical menu display:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> current_category = &quot;&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(key, price) in &amp;menu_hierarchy {
</span><span>        </span><span style="color:#b48ead;">let</span><span> parts: Vec&lt;&amp;</span><span style="color:#b48ead;">str</span><span>&gt; = key.</span><span style="color:#96b5b4;">split</span><span>(&#39;</span><span style="color:#a3be8c;">:</span><span>&#39;).</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>        </span><span style="color:#b48ead;">if</span><span> parts.</span><span style="color:#96b5b4;">len</span><span>() &gt;= </span><span style="color:#d08770;">3 </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> category = parts[^</span><span style="color:#d08770;">1</span><span>];
</span><span>            </span><span style="color:#b48ead;">let</span><span> item = parts[^</span><span style="color:#d08770;">2</span><span>];
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> category != current_category {
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">     📂 </span><span style="color:#d08770;">{}</span><span>&quot;, category);
</span><span>                current_category = category;
</span><span>            }
</span><span>
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">       • </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span>&quot;, item, price);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Advanced Technique 5: Range-based inventory management
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📦 Technique 5: Range-Based Inventory Alerts</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> inventory_levels = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Item ID ranges: 1000-1999 = Vegetables, 2000-2999 = Grains, etc.
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1001</span><span>, (&quot;</span><span style="color:#a3be8c;">Tomatoes</span><span>&quot;, </span><span style="color:#d08770;">45</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1002</span><span>, (&quot;</span><span style="color:#a3be8c;">Lettuce</span><span>&quot;, </span><span style="color:#d08770;">23</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1003</span><span>, (&quot;</span><span style="color:#a3be8c;">Onions</span><span>&quot;, </span><span style="color:#d08770;">67</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">2001</span><span>, (&quot;</span><span style="color:#a3be8c;">Quinoa</span><span>&quot;, </span><span style="color:#d08770;">89</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">2002</span><span>, (&quot;</span><span style="color:#a3be8c;">Brown Rice</span><span>&quot;, </span><span style="color:#d08770;">34</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">3001</span><span>, (&quot;</span><span style="color:#a3be8c;">Olive Oil</span><span>&quot;, </span><span style="color:#d08770;">12</span><span>));
</span><span>    inventory_levels.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">3002</span><span>, (&quot;</span><span style="color:#a3be8c;">Vinegar</span><span>&quot;, </span><span style="color:#d08770;">8</span><span>));
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Check vegetable inventory (1000-1999)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🥬 Vegetable inventory status:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(id, (name, quantity)) in inventory_levels.</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1000</span><span>..</span><span style="color:#d08770;">2000</span><span>) {
</span><span>        </span><span style="color:#b48ead;">let</span><span> status = </span><span style="color:#b48ead;">if </span><span>*quantity &lt; </span><span style="color:#d08770;">30 </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">🚨 LOW</span><span>&quot;
</span><span>        } </span><span style="color:#b48ead;">else if </span><span>*quantity &lt; </span><span style="color:#d08770;">50 </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">⚠️ MEDIUM</span><span>&quot;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">✅ GOOD</span><span>&quot;
</span><span>        };
</span><span>
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">) → </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> units </span><span style="color:#d08770;">{}</span><span>&quot;, name, id, quantity, status);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Check condiment inventory (3000-3999)
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🧂 Condiment inventory status:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(id, (name, quantity)) in inventory_levels.</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">3000</span><span>..</span><span style="color:#d08770;">4000</span><span>) {
</span><span>        </span><span style="color:#b48ead;">let</span><span> status = </span><span style="color:#b48ead;">if </span><span>*quantity &lt; </span><span style="color:#d08770;">15 </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">🚨 LOW</span><span>&quot;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            &quot;</span><span style="color:#a3be8c;">✅ GOOD</span><span>&quot;
</span><span>        };
</span><span>
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">) → </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> units </span><span style="color:#d08770;">{}</span><span>&quot;, name, id, quantity, status);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎓 Advanced BTreeMap Benefits:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Time-series analysis with range queries</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Rolling window calculations</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Capacity planning with sorted data</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Hierarchical organization with composite keys</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Range-based categorization and filtering</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Natural ordering enables sophisticated algorithms</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_advanced_btreemap</span><span>();
</span><span>}
</span></code></pre>
<h2 id="best-practices-and-common-patterns">Best Practices and Common Patterns</h2>
<h3 id="professional-btreemap-usage">Professional BTreeMap Usage</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_btreemap_best_practices</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">✅ BTreeMap Best Practices - Professional Restaurant Management</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;70}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 1: Choose appropriate key types
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">🔑 Best Practice 1: Key Type Selection</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// ✅ Good: Use types that have natural ordering
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> daily_revenue: BTreeMap&lt;String, </span><span style="color:#b48ead;">f64</span><span>&gt; = BTreeMap::new();  </span><span style="color:#a7adba;">// Dates as strings
</span><span>    daily_revenue.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-15</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">2847.50</span><span>);
</span><span>    daily_revenue.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-14</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">2234.75</span><span>);
</span><span>    daily_revenue.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-16</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), </span><span style="color:#d08770;">3102.25</span><span>);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Date strings sort chronologically:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(date, revenue) in daily_revenue.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">3</span><span>) {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → $</span><span style="color:#d08770;">{:.2}</span><span>&quot;, date, revenue);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// ✅ Better: Use types designed for ordering
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::time::SystemTime;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> time_based_events: BTreeMap&lt;</span><span style="color:#b48ead;">u64</span><span>, String&gt; = BTreeMap::new();  </span><span style="color:#a7adba;">// Unix timestamps
</span><span>    time_based_events.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1705123200</span><span>, &quot;</span><span style="color:#a3be8c;">Morning prep</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());   </span><span style="color:#a7adba;">// 09:00
</span><span>    time_based_events.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1705129200</span><span>, &quot;</span><span style="color:#a3be8c;">Lunch service</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());  </span><span style="color:#a7adba;">// 11:30
</span><span>    time_based_events.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1705143600</span><span>, &quot;</span><span style="color:#a3be8c;">Dinner service</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()); </span><span style="color:#a7adba;">// 18:00
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Timestamps provide precise ordering</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 2: Efficient range operations
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📊 Best Practice 2: Efficient Range Operations</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> order_priorities = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Use range-friendly keys for efficient queries
</span><span>    order_priorities.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1</span><span>, &quot;</span><span style="color:#a3be8c;">Low priority</span><span>&quot;);
</span><span>    order_priorities.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">5</span><span>, &quot;</span><span style="color:#a3be8c;">Normal priority</span><span>&quot;);
</span><span>    order_priorities.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">8</span><span>, &quot;</span><span style="color:#a3be8c;">High priority</span><span>&quot;);
</span><span>    order_priorities.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">9</span><span>, &quot;</span><span style="color:#a3be8c;">Urgent</span><span>&quot;);
</span><span>    order_priorities.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">10</span><span>, &quot;</span><span style="color:#a3be8c;">Emergency</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Efficient high-priority filtering
</span><span>    </span><span style="color:#b48ead;">let</span><span> high_priority_orders: Vec&lt;_&gt; = order_priorities
</span><span>        .</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">8</span><span>..)  </span><span style="color:#a7adba;">// O(log n + k) where k is result size
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ⚡ High priority orders (efficient range query):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(priority, description) in high_priority_orders {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Priority </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span>&quot;, priority, description);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 3: Memory-efficient operations
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">💾 Best Practice 3: Memory Efficiency</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// ✅ Use references when possible to avoid cloning
</span><span>    </span><span style="color:#b48ead;">let</span><span> menu_items = BTreeMap::from([
</span><span>        (&quot;</span><span style="color:#a3be8c;">Appetizer</span><span>&quot;, vec![&quot;</span><span style="color:#a3be8c;">Hummus</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Bruschetta</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Salad</span><span>&quot;]),
</span><span>        (&quot;</span><span style="color:#a3be8c;">Main</span><span>&quot;, vec![&quot;</span><span style="color:#a3be8c;">Quinoa Bowl</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Burger</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Pasta</span><span>&quot;]),
</span><span>        (&quot;</span><span style="color:#a3be8c;">Dessert</span><span>&quot;, vec![&quot;</span><span style="color:#a3be8c;">Mousse</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Tart</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Ice Cream</span><span>&quot;]),
</span><span>    ]);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Efficient iteration without cloning
</span><span>    </span><span style="color:#b48ead;">for </span><span>(category, items) in &amp;menu_items {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">   📋 </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> items</span><span>&quot;, category, items.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>        </span><span style="color:#b48ead;">for</span><span> item in items {
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">     • </span><span style="color:#d08770;">{}</span><span>&quot;, item);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 4: Error handling patterns
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🚨 Best Practice 4: Robust Error Handling</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> table_reservations = BTreeMap::new();
</span><span>    table_reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Johnson party of 4</span><span>&quot;);
</span><span>    table_reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Smith anniversary dinner</span><span>&quot;);
</span><span>    table_reservations.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">20:15</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Davis business meeting</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe reservation lookup
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">find_reservation</span><span>(
</span><span>        </span><span style="color:#bf616a;">reservations</span><span>: &amp;BTreeMap&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>&gt;,
</span><span>        </span><span style="color:#bf616a;">time</span><span>: &amp;</span><span style="color:#b48ead;">str
</span><span>    ) -&gt; Result&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, String&gt; {
</span><span>        reservations.</span><span style="color:#96b5b4;">get</span><span>(time)
</span><span>            .</span><span style="color:#96b5b4;">ok_or_else</span><span>(|| format!(&quot;</span><span style="color:#a3be8c;">No reservation found for </span><span style="color:#d08770;">{}</span><span>&quot;, time))
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe range queries with validation
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_evening_reservations</span><span>(
</span><span>        </span><span style="color:#bf616a;">reservations</span><span>: &amp;BTreeMap&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>&gt;
</span><span>    ) -&gt; Vec&lt;(&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>        reservations
</span><span>            .</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;..&quot;</span><span style="color:#a3be8c;">22:00</span><span>&quot;)
</span><span>            .</span><span style="color:#96b5b4;">map</span><span>(|(&amp;</span><span style="color:#bf616a;">time</span><span>, &amp;</span><span style="color:#bf616a;">details</span><span>)| (time, details))
</span><span>            .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">find_reservation</span><span>(&amp;table_reservations, &quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;) {
</span><span>        Ok(details) =&gt; println!(&quot;</span><span style="color:#a3be8c;">   ✅ Found reservation: </span><span style="color:#d08770;">{}</span><span>&quot;, details),
</span><span>        Err(error) =&gt; println!(&quot;</span><span style="color:#a3be8c;">   ❌ </span><span style="color:#d08770;">{}</span><span>&quot;, error),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> evening_reservations = </span><span style="color:#96b5b4;">get_evening_reservations</span><span>(&amp;table_reservations);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📅 Evening reservations: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> found</span><span>&quot;, evening_reservations.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 5: Performance optimization patterns
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">⚡ Best Practice 5: Performance Optimization</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Pre-allocate when you know the approximate size (not available for BTreeMap directly)
</span><span>    </span><span style="color:#a7adba;">// But you can batch insert for better performance
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> large_dataset = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Batch insert sorted data for optimal performance
</span><span>    </span><span style="color:#b48ead;">let</span><span> sorted_data = [
</span><span>        (</span><span style="color:#d08770;">1</span><span>, &quot;</span><span style="color:#a3be8c;">First</span><span>&quot;),
</span><span>        (</span><span style="color:#d08770;">2</span><span>, &quot;</span><span style="color:#a3be8c;">Second</span><span>&quot;),
</span><span>        (</span><span style="color:#d08770;">3</span><span>, &quot;</span><span style="color:#a3be8c;">Third</span><span>&quot;),
</span><span>        (</span><span style="color:#d08770;">4</span><span>, &quot;</span><span style="color:#a3be8c;">Fourth</span><span>&quot;),
</span><span>        (</span><span style="color:#d08770;">5</span><span>, &quot;</span><span style="color:#a3be8c;">Fifth</span><span>&quot;),
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#a7adba;">// ✅ Inserting pre-sorted data is more efficient
</span><span>    </span><span style="color:#b48ead;">for </span><span>(key, value) in sorted_data {
</span><span>        large_dataset.</span><span style="color:#96b5b4;">insert</span><span>(key, value);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Inserted </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> items efficiently</span><span>&quot;, large_dataset.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Best Practice 6: Type-safe key design
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🔒 Best Practice 6: Type-Safe Key Design</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Define custom key types for better type safety
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, PartialEq, Eq, PartialOrd, Ord)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>TimeSlot {
</span><span>        </span><span style="color:#bf616a;">hour</span><span>: </span><span style="color:#b48ead;">u8</span><span>,
</span><span>        </span><span style="color:#bf616a;">minute</span><span>: </span><span style="color:#b48ead;">u8</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>TimeSlot {
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">hour</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">minute</span><span>: </span><span style="color:#b48ead;">u8</span><span>) -&gt; Result&lt;</span><span style="color:#b48ead;">Self</span><span>, String&gt; {
</span><span>            </span><span style="color:#b48ead;">if</span><span> hour &gt; </span><span style="color:#d08770;">23 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>Err(&quot;</span><span style="color:#a3be8c;">Hour must be 0-23</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">if</span><span> minute &gt; </span><span style="color:#d08770;">59 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>Err(&quot;</span><span style="color:#a3be8c;">Minute must be 0-59</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>            }
</span><span>            Ok(TimeSlot { hour, minute })
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>std::fmt::Display </span><span style="color:#b48ead;">for </span><span>TimeSlot {
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fmt</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">f</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</span><span>            write!(f, &quot;</span><span style="color:#d08770;">{:02}</span><span style="color:#a3be8c;">:</span><span style="color:#d08770;">{:02}</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.hour, </span><span style="color:#bf616a;">self</span><span>.minute)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> schedule = BTreeMap::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Ok(time1) = TimeSlot::new(</span><span style="color:#d08770;">18</span><span>, </span><span style="color:#d08770;">0</span><span>) {
</span><span>        schedule.</span><span style="color:#96b5b4;">insert</span><span>(time1, &quot;</span><span style="color:#a3be8c;">Dinner service starts</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Ok(time2) = TimeSlot::new(</span><span style="color:#d08770;">19</span><span>, </span><span style="color:#d08770;">30</span><span>) {
</span><span>        schedule.</span><span style="color:#96b5b4;">insert</span><span>(time2, &quot;</span><span style="color:#a3be8c;">Peak dinner time</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Ok(time3) = TimeSlot::new(</span><span style="color:#d08770;">21</span><span>, </span><span style="color:#d08770;">0</span><span>) {
</span><span>        schedule.</span><span style="color:#96b5b4;">insert</span><span>(time3, &quot;</span><span style="color:#a3be8c;">Last orders</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Type-safe time-based schedule:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(time, event) in &amp;schedule {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> → </span><span style="color:#d08770;">{}</span><span>&quot;, time, event);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">📋 BTreeMap Best Practices Summary:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Choose keys with natural, meaningful ordering</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Use range queries instead of filtering when possible</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Prefer references over cloning for read operations</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Implement proper error handling for missing keys</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Insert pre-sorted data when possible for performance</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Use custom key types for better type safety</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ✅ Consider BTreeMap for any ordered, searchable data</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">🎯 When to Use BTreeMap:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📅 Time-series data (logs, events, schedules)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📊 Ordered statistics (rankings, scores, metrics)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🔍 Range-based queries (time periods, score ranges)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📋 Hierarchical data (categories, levels, priorities)</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   🎮 Leaderboards and competitive rankings</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   📈 Financial data (prices, transactions, reports)</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_btreemap_best_practices</span><span>();
</span><span>}
</span></code></pre>
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<h3 id="mental-model-the-perfect-restaurant-reservation-system"><strong>Mental Model: The Perfect Restaurant Reservation System</strong></h3>
<p>Remember our restaurant reservation system analogy:</p>
<ul>
<li>🌳 <strong>BTreeMap</strong> = <strong>Automatic chronological organizer</strong> - Keeps everything perfectly sorted</li>
<li>📅 <strong>Ordered storage</strong> = <strong>Time-based reservation book</strong> - Always see what's coming next</li>
<li>🔍 <strong>Range queries</strong> = <strong>Time period analysis</strong> - "Show me all 6-8 PM reservations"</li>
<li>📊 <strong>Sorted iteration</strong> = <strong>Systematic processing</strong> - Handle events in logical order</li>
<li>⚡ <strong>O(log n) operations</strong> = <strong>Efficient tree navigation</strong> - Fast even with thousands of entries</li>
</ul>
<h3 id="essential-btreemap-operations-quick-reference"><strong>Essential BTreeMap Operations Quick Reference</strong></h3>
<table><thead><tr><th style="text-align: left"><strong>Operation</strong></th><th style="text-align: left"><strong>Syntax</strong></th><th style="text-align: left"><strong>Use Case</strong></th><th style="text-align: left"><strong>Performance</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Create</strong></td><td style="text-align: left"><code>BTreeMap::new()</code></td><td style="text-align: left">Empty ordered map</td><td style="text-align: left">O(1)</td></tr>
<tr><td style="text-align: left"><strong>Insert</strong></td><td style="text-align: left"><code>map.insert(key, value)</code></td><td style="text-align: left">Add/update entry</td><td style="text-align: left">O(log n)</td></tr>
<tr><td style="text-align: left"><strong>Get</strong></td><td style="text-align: left"><code>map.get(&amp;key)</code></td><td style="text-align: left">Safe access</td><td style="text-align: left">O(log n)</td></tr>
<tr><td style="text-align: left"><strong>Range</strong></td><td style="text-align: left"><code>map.range(start..end)</code></td><td style="text-align: left">Query ranges</td><td style="text-align: left">O(log n + k)</td></tr>
<tr><td style="text-align: left"><strong>First/Last</strong></td><td style="text-align: left"><code>map.first_key_value()</code></td><td style="text-align: left">Boundary access</td><td style="text-align: left">O(log n)</td></tr>
<tr><td style="text-align: left"><strong>Remove</strong></td><td style="text-align: left"><code>map.remove(&amp;key)</code></td><td style="text-align: left">Delete entry</td><td style="text-align: left">O(log n)</td></tr>
</tbody></table>
<h3 id="btreemap-s-killer-features"><strong>BTreeMap's Killer Features</strong></h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::collections::BTreeMap;
</span><span>
</span><span style="color:#a7adba;">// Automatic ordering
</span><span style="color:#b48ead;">let mut</span><span> events = BTreeMap::new();
</span><span>events.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">19:30</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Dinner</span><span>&quot;);
</span><span>events.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">11:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Lunch</span><span>&quot;);
</span><span>events.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">08:00</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Breakfast</span><span>&quot;);
</span><span style="color:#a7adba;">// Always iterates: 08:00, 11:00, 19:30
</span><span>
</span><span style="color:#a7adba;">// Range queries (impossible with HashMap!)
</span><span style="color:#b48ead;">for </span><span>(time, event) in events.</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">12:00</span><span>&quot;..&quot;</span><span style="color:#a3be8c;">18:00</span><span>&quot;) {
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span>&quot;, time, event); </span><span style="color:#a7adba;">// Only afternoon events
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Boundary access
</span><span style="color:#b48ead;">let </span><span>(first_time, _) = events.</span><span style="color:#96b5b4;">first_key_value</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span style="color:#b48ead;">let </span><span>(last_time, _) = events.</span><span style="color:#96b5b4;">last_key_value</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span></code></pre>
<h3 id="decision-guide-btreemap-vs-hashmap"><strong>Decision Guide: BTreeMap vs HashMap</strong></h3>
<p><strong>✅ Choose BTreeMap when:</strong></p>
<ul>
<li>You need data in sorted order</li>
<li>You want range queries ("all items between X and Y")</li>
<li>You're working with time-series data</li>
<li>You need deterministic iteration order</li>
<li>You want to find min/max efficiently</li>
<li>You're building leaderboards or rankings</li>
</ul>
<p><strong>✅ Choose HashMap when:</strong></p>
<ul>
<li>You need fastest possible lookups</li>
<li>Order doesn't matter</li>
<li>You're doing lots of random access</li>
<li>Memory efficiency is critical</li>
</ul>
<h3 id="common-btreemap-patterns"><strong>Common BTreeMap Patterns</strong></h3>
<p><strong>Time-Series Analysis:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> daily_sales = BTreeMap::new();
</span><span>daily_sales.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-15</span><span>&quot;, </span><span style="color:#d08770;">2847.50</span><span>);
</span><span>daily_sales.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-14</span><span>&quot;, </span><span style="color:#d08770;">2234.75</span><span>);
</span><span>
</span><span style="color:#a7adba;">// Get week&#39;s data
</span><span style="color:#b48ead;">let</span><span> week_total: </span><span style="color:#b48ead;">f64 </span><span>= daily_sales
</span><span>    .</span><span style="color:#96b5b4;">range</span><span>(&quot;</span><span style="color:#a3be8c;">2024-01-10</span><span>&quot;..&quot;</span><span style="color:#a3be8c;">2024-01-17</span><span>&quot;)
</span><span>    .</span><span style="color:#96b5b4;">map</span><span>(|(_, </span><span style="color:#bf616a;">sales</span><span>)| sales)
</span><span>    .</span><span style="color:#96b5b4;">sum</span><span>();
</span></code></pre>
<p><strong>Priority Queues:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> task_priority = BTreeMap::new();
</span><span>task_priority.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">1</span><span>, &quot;</span><span style="color:#a3be8c;">Low priority task</span><span>&quot;);
</span><span>task_priority.</span><span style="color:#96b5b4;">insert</span><span>(</span><span style="color:#d08770;">9</span><span>, &quot;</span><span style="color:#a3be8c;">High priority task</span><span>&quot;);
</span><span>
</span><span style="color:#a7adba;">// Process highest priority first
</span><span style="color:#b48ead;">while let </span><span>Some((priority, task)) = task_priority.</span><span style="color:#96b5b4;">pop_last</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Processing priority </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span>&quot;, priority, task);
</span><span>}
</span></code></pre>
<p><strong>Hierarchical Data:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> menu = BTreeMap::new();
</span><span>menu.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">1:Appetizers:Hummus</span><span>&quot;, </span><span style="color:#d08770;">8.99</span><span>);
</span><span>menu.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">2:Mains:Quinoa Bowl</span><span>&quot;, </span><span style="color:#d08770;">15.99</span><span>);
</span><span>menu.</span><span style="color:#96b5b4;">insert</span><span>(&quot;</span><span style="color:#a3be8c;">3:Desserts:Mousse</span><span>&quot;, </span><span style="color:#d08770;">6.99</span><span>);
</span><span style="color:#a7adba;">// Automatic grouping by category prefix
</span></code></pre>
<h3 id="performance-characteristics"><strong>Performance Characteristics</strong></h3>
<ul>
<li><strong>Insert/Delete/Search:</strong> O(log n) - Consistently fast even with millions of items</li>
<li><strong>Iteration:</strong> O(n) - Always in sorted order</li>
<li><strong>Range queries:</strong> O(log n + k) - where k is the number of results</li>
<li><strong>Memory:</strong> Slightly higher overhead than HashMap, but reasonable</li>
<li><strong>Cache performance:</strong> Good locality for range operations</li>
</ul>
<h3 id="best-practices-checklist"><strong>Best Practices Checklist</strong></h3>
<p><strong>✅ DO:</strong></p>
<ul>
<li>Use BTreeMap for any naturally ordered data</li>
<li>Leverage range queries instead of filtering</li>
<li>Use custom key types for type safety</li>
<li>Handle <code>Option</code> returns from <code>get()</code> properly</li>
<li>Take advantage of first/last methods for boundaries</li>
<li>Use <code>&amp;</code> for read-only access to avoid cloning</li>
</ul>
<p><strong>❌ DON'T:</strong></p>
<ul>
<li>Use BTreeMap if you only need random access (use HashMap)</li>
<li>Ignore the ordering - if you don't need it, don't pay for it</li>
<li>Use complex keys without considering performance</li>
<li>Forget that keys must implement <code>Ord</code> trait</li>
<li>Use unwrap() on get() without checking</li>
</ul>
<h3 id="real-world-applications"><strong>Real-World Applications</strong></h3>
<p><strong>BTreeMap excels for:</strong></p>
<ul>
<li>📅 <strong>Calendar and scheduling systems</strong> - Natural time ordering</li>
<li>📊 <strong>Analytics and reporting</strong> - Ordered metrics and time-series</li>
<li>🎮 <strong>Game leaderboards</strong> - Score-based rankings</li>
<li>💰 <strong>Financial applications</strong> - Transaction histories, price data</li>
<li>📈 <strong>Monitoring systems</strong> - Time-stamped logs and metrics</li>
<li>🏪 <strong>Inventory management</strong> - Product codes, priority levels</li>
</ul>
<h3 id="the-professional-advantage"><strong>The Professional Advantage</strong></h3>
<p><strong>Mastering BTreeMap in Rust is like having a world-class restaurant reservation system</strong> that automatically organizes everything perfectly:</p>
<ul>
<li>📅 <strong>Natural organization</strong> - Your data stays perfectly sorted without effort</li>
<li>🔍 <strong>Powerful queries</strong> - Find exactly what you need with range operations</li>
<li>⚡ <strong>Predictable performance</strong> - O(log n) operations scale beautifully</li>
<li>🎯 <strong>Type safety</strong> - Rust ensures your ordering logic is correct</li>
<li>📊 <strong>Iterator efficiency</strong> - Sorted iteration enables advanced algorithms</li>
</ul>
<p><strong>Understanding BTreeMap transforms you from a programmer who struggles with ordered data to a systems expert</strong> who chooses the perfect data structure for each use case. Just as a master restaurateur uses sophisticated reservation systems to handle complex scheduling efficiently, a skilled Rust programmer leverages BTreeMap's ordered nature to build elegant solutions for time-series data, rankings, analytics, and any scenario where order matters.</p>
<p>This knowledge of BTreeMap, combined with understanding when to choose it over HashMap, makes you a more versatile and effective Rust programmer who can tackle complex data organization challenges with confidence and efficiency![^1][^2][^3]</p>
<ol>
<li>https://doc.rust-lang.org/std/collections/struct.BTreeMap.html</li>
<li>https://www.linkedin.com/pulse/hashmap-btreemap-rust-collections-gabriel-puiggrós</li>
<li>https://www.w3resource.com/rust-tutorial/rust-maps-hashmap-btreemap.php</li>
<li>https://faultlore.com/blah/rust-btree-case/</li>
<li>https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/collections/struct.BTreeMap.html</li>
<li>https://docs.rs/btree-slab/latest/btree_slab/type.BTreeMap.html</li>
<li>https://stackoverflow.com/questions/58357421/difference-between-iterating-over-btreemap-and-btreemap</li>
<li>https://www.reddit.com/r/rust/comments/zsws3k/introducing_rangeboundsmap_a_btreemaplike/</li>
<li>https://www.youtube.com/watch?v=DBdbe2QUlf8</li>
<li>https://doc.rust-lang.org/std/collections/index.html</li>
<li>https://stackoverflow.com/questions/75566040/iterating-through-btreemap-using-range-question-on-the-type-being-iterated-o</li>
<li>https://users.rust-lang.org/t/interface-the-btreemap-and-hashmap/97937</li>
<li>https://rust-exercises.com/100-exercises/06_ticket_management/16_btreemap.html</li>
<li>https://cglab.ca/~abeinges/blah/rust-btree-case/</li>
<li>https://www.reddit.com/r/rust/comments/xbkuc7/btreemap_vs_hashmap/</li>
<li>https://docs.rs/ic-stable-structures/latest/ic_stable_structures/btreemap/struct.BTreeMap.html</li>
<li>https://www.dotnetperls.com/btreemap-rust</li>
<li>https://www.thecodedmessage.com/posts/prefix-ranges/</li>
<li>https://docs.rs/ex3-ic-stable-structures/latest/ex3_ic_stable_structures/btreemap/struct.BTreeMap.html</li>
<li>https://www.thecodedmessage.com/rust-c-book/entries.html</li>
<li>https://stackoverflow.com/questions/76825499/interface-the-btreemap-and-hashmap-in-rust</li>
<li>https://users.rust-lang.org/t/how-to-construct-a-btreemap-of-fixed-values-in-rust/115576</li>
<li>https://stackoverflow.com/questions/70635142/btreemap-of-f64s</li>
<li>https://stackoverflow.com/questions/74473058/how-to-use-common-btreemap-variable-in-rustsingle-thread</li>
<li>https://users.rust-lang.org/t/iterating-over-my-btreemap/108764</li>
</ol>

    
        </div>

    </article>
</main>


    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/elasticlunr.min.js" defer></script>
    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/search_index.en.js" defer></script>
<script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/js.js" defer></script>

</body>
</html>
