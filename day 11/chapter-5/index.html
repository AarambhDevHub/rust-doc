<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://aarambhdevhub.github.io/rust-doc/main.css">
    <link rel="icon" href="https://www.rust-lang.org/static/images/favicon-16x16.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> Rust Programming Course! | Ownership of Struct Data </title>
</head>
<body>

<main>
    
    <nav>
            <a href="https:&#x2F;&#x2F;aarambhdevhub.github.io&#x2F;rust-doc&#x2F;">
                        <img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="logo"/>
                    </a>
                <!-- -->

            <a href="javascript:void(0);" onclick="burger()" id="mobile" class="ms-Icon--GlobalNavButton"></a>
            <div id="trees">
                <input class="tree-toggle" type="checkbox" id="day-1-introduction"
                           />
                    <label class="tree-toggle-label"
                           for="day-1-introduction">Day 1: Introduction</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-1/">What is Rust and why use it?</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-2/">Installing Rust Toolchain (rustup, cargo)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-3/">Setting up Development (VS Code + Hello World)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-4/">Understanding Cargo Project Structure</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-2-basic-syntax-variables"
                           />
                    <label class="tree-toggle-label"
                           for="day-2-basic-syntax-variables">Day 2: Basic Syntax &amp; Variables</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-1/">Variables and Mutability in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-2/">Data Types in Rust: Integers, Floats, Booleans, and Characters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-3/">Constants vs Variables</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-4/">Understanding Shadowing in Rust: A Practical Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-5/">Basic Input&#x2F;Output</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-3-functions-control-flow"
                           />
                    <label class="tree-toggle-label"
                           for="day-3-functions-control-flow">Day 3: Functions &amp; Control Flow</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-1/">Function Syntax and Parameters in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-2/">Return Values and Expressions vs Statements</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-3/">If&#x2F;Else Statements in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-4/">Match Expressions in Rust: Powerful Pattern Matching</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-5/">Loops in Rust: loop, while, for Explained</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-4-data-types-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-4-data-types-deep-dive">Day 4: Data Types Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-1/">Compound Types (Tuples, Arrays)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-2/">String vs &amp;str in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-3/">Vector Basics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-4/">Type Annotations and Inference in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-5/">Practical Rust Exercises</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-5-practice-review"
                           />
                    <label class="tree-toggle-label"
                           for="day-5-practice-review">Day 5: Practice &amp; Review</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 5/chapter-1/">Day 5: Practice &amp; Review</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-6-ownership-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-6-ownership-fundamentals">Day 6: Ownership Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-1/">Ownership in Rust: A Detailed Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-2/">Stack vs Heap in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-3/">Understanding Ownership in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-4/">Move Semantics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-5/">Copy Trait in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-7-references-borrowing"
                           />
                    <label class="tree-toggle-label"
                           for="day-7-references-borrowing">Day 7: References &amp; Borrowing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-1/">Immutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-2/">Mutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-3/">Borrowing Rules</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-4/">Reference Lifetime Basics</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-5/">Common Borrowing Errors and Solutions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-8-slices"
                           />
                    <label class="tree-toggle-label"
                           for="day-8-slices">Day 8: Slices</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/">String Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-2/">Array Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-3/">Slice Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-4/">Practical Applications</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-5/">Memory Safety Benefits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-9-advanced-ownership"
                           />
                    <label class="tree-toggle-label"
                           for="day-9-advanced-ownership">Day 9: Advanced Ownership</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-1/">Clone Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-2/">Drop Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-3/">RAII Pattern</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-4/">Memory Management Comparison with Other Languages</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-5/">Best Practices (Advanced Ownership)</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-10-ownership-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-10-ownership-practice">Day 10: Ownership Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-1/">Complex Ownership Scenarios</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-2/">Debugging Ownership Errors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-3/">Code Refactoring Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-4/">Group Problem-Solving</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-11-structs-basics"
                           checked/>
                    <label class="tree-toggle-label"
                           for="day-11-structs-basics">Day 11: Structs Basics</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-1/">Defining and Instantiating Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-2/">Field Access and Modification</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-3/">Tuple Structs and Unit Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-4/">Struct Update Syntax</a>
                            </li>

                            <li class="active">
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/">Ownership of Struct Data</a>
                            </li>

                            
                                    
                                    
                                        <ul id="toc">
                                            <li><a href="
                                                        https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#ownership-of-struct-data-in-rust-comprehensive-documentation">Ownership of Struct Data in Rust: Comprehensive Documentation</a>
                                                    <ul>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#fundamental-ownership-rules-for-structs">Fundamental Ownership Rules for Structs</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#move-semantics-with-struct-data">Move Semantics with Struct Data</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#partial-moves-from-structs">Partial Moves from Structs</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#borrowing-struct-data">Borrowing Struct Data</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#field-level-borrowing">Field-Level Borrowing</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#ownership-transfer-patterns">Ownership Transfer Patterns</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#advanced-ownership-patterns">Advanced Ownership Patterns</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#performance-considerations">Performance Considerations</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#best-practices-for-struct-ownership">Best Practices for Struct Ownership</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/#summary-and-key-takeaways">Summary and Key Takeaways</a>
                                                                </li>
                                                            </ul>
                                                    </li>
                                            </ul>
                                    </ul>
                <input class="tree-toggle" type="checkbox" id="day-12-methods-associated-functions"
                           />
                    <label class="tree-toggle-label"
                           for="day-12-methods-associated-functions">Day 12: Methods &amp; Associated Functions</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-1/">Implementing Methods with impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-2/">&amp;self, &amp;mut self, and self</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-3/">Associated Functions (like Constructors)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-4/">Multiple impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-5/">Method Chaining</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-13-advanced-struct-concepts"
                           />
                    <label class="tree-toggle-label"
                           for="day-13-advanced-struct-concepts">Day 13: Advanced Struct Concepts</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-1/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-2/">Debug Trait and Custom Formatting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-3/">Builder Pattern Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-4/">Struct Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-5/">Best Practices for Struct Design</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-14-enums-pattern-matching"
                           />
                    <label class="tree-toggle-label"
                           for="day-14-enums-pattern-matching">Day 14: Enums &amp; Pattern Matching</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-1/">Defining Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-2/">Enum Variants with Data</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-3/">Option&lt;T&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-4/">Result&lt;T, E&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-5/">Advanced Match Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-15-practice-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-15-practice-project">Day 15: Practice Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 15/chapter-1/">Building a Simple CLI Calculator in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-16-vectors"
                           />
                    <label class="tree-toggle-label"
                           for="day-16-vectors">Day 16: Vectors</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-1/">Creating and Updating Vectors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-2/">Vector Methods: push, pop, iter</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-3/">Accessing Vector Elements Safely</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-4/">Vector of Different Types with Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-5/">Performance Considerations</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-17-hashmaps-other-collections"
                           />
                    <label class="tree-toggle-label"
                           for="day-17-hashmaps-other-collections">Day 17: HashMaps &amp; Other Collections</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-1/">HashMap Creation and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-2/">Keys and Values Ownership</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-3/">HashMap Methods and Iteration</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-4/">When to Use Different Collections</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/">BTreeMap Introduction</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-18-error-handling"
                           />
                    <label class="tree-toggle-label"
                           for="day-18-error-handling">Day 18: Error Handling</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-1/">Panic! and When to Use It</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-2/">Result&lt;T, E&gt; in Depth</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-3/">The ? Operator in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-4/">Creating Custom Error Types in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-5/">Error Propagation Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-19-strings-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-19-strings-deep-dive">Day 19: Strings Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-1/">String vs &amp;str Revisited</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-2/">String Methods and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-5/">Performance Considerations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-3/">UTF-8 and Character Encoding</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-4/">String Concatenation Techniques</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-20-mini-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-20-mini-project">Day 20: Mini Project</label>

                    <ul class="subtree">
                        </ul>
                <input class="tree-toggle" type="checkbox" id="day-21-generic-functions-structs"
                           />
                    <label class="tree-toggle-label"
                           for="day-21-generic-functions-structs">Day 21: Generic Functions &amp; Structs</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-1/">Generic Function Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-2/">Generic Structs and Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-3/">Type Parameters and Constraints</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-4/">Monomorphization Concept</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-5/">Generic Collections</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-22-traits-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-22-traits-fundamentals">Day 22: Traits Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-1/">Defining Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-2/">Implementing Traits for Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-3/">Default Implementations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-4/">Trait as Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-5/">Trait Bounds</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-23-advanced-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-23-advanced-traits">Day 23: Advanced Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-1/">Trait Objects and Dynamic Dispatch</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-2/">Supertraits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-3/">Associated Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-4/">Orphan Rule</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-5/">Coherence Rules</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-24-standard-library-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-24-standard-library-traits">Day 24: Standard Library Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-1/">Iterator Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-2/">From and Into Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-3/">Display and Debug Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-4/">Clone and Copy Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-5/">PartialEq and Eq Traits</a>
                            </li>

                            </ul>
                </div>
        </nav>
    <article>

        <div id="on_right">
                <span id="search-ico" class="ms-Icon--Search"></span>
            </div>
            <div class="search-container">
                <input id="search" type="search" placeholder="Search as you type...">
                <div class="search-results">
                    <div class="search-results__header"></div>
                    <ul class="search-results__items"></ul>
                </div>
            </div>
        <div id="wrap">
            
        <h1 id="ownership-of-struct-data-in-rust-comprehensive-documentation">Ownership of Struct Data in Rust: Comprehensive Documentation</h1>
<p>Understanding ownership of struct data is fundamental to writing safe and efficient Rust code. Rust's ownership system applies to structs in sophisticated ways that ensure memory safety while providing fine-grained control over data access patterns. This comprehensive guide explores how ownership rules interact with struct data, covering everything from basic ownership transfer to advanced borrowing patterns.</p>
<h2 id="fundamental-ownership-rules-for-structs">Fundamental Ownership Rules for Structs</h2>
<h3 id="core-ownership-principles">Core Ownership Principles</h3>
<p>Rust's ownership rules apply to structs just as they do to all other types, but with additional complexity due to the composite nature of struct data[1][2]. The fundamental rules remain:</p>
<ol>
<li><strong>Each value has exactly one owner</strong></li>
<li><strong>Only one owner can exist at a time</strong></li>
<li><strong>When the owner goes out of scope, the value is dropped</strong></li>
</ol>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>User {
</span><span>    </span><span style="color:#bf616a;">username</span><span>: String,    </span><span style="color:#a7adba;">// Owned data on heap
</span><span>    </span><span style="color:#bf616a;">email</span><span>: String,       </span><span style="color:#a7adba;">// Owned data on heap
</span><span>    </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u32</span><span>,           </span><span style="color:#a7adba;">// Copy data on stack
</span><span>    </span><span style="color:#bf616a;">active</span><span>: </span><span style="color:#b48ead;">bool</span><span>,       </span><span style="color:#a7adba;">// Copy data on stack
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> user1 = User {
</span><span>        username: String::from(&quot;</span><span style="color:#a3be8c;">alice123</span><span>&quot;),
</span><span>        email: String::from(&quot;</span><span style="color:#a3be8c;">alice@example.com</span><span>&quot;),
</span><span>        age: </span><span style="color:#d08770;">30</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// user1 owns all the data in the struct
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">User1: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user1);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Transfer ownership to user2
</span><span>    </span><span style="color:#b48ead;">let</span><span> user2 = user1;  </span><span style="color:#a7adba;">// Move occurs here
</span><span>
</span><span>    </span><span style="color:#a7adba;">// user1 is no longer valid - compile error if used
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;User1: {:?}&quot;, user1);  // Error: value borrowed after move
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">User2: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user2);  </span><span style="color:#a7adba;">// user2 now owns the data
</span><span>}
</span></code></pre>
<h3 id="struct-ownership-vs-field-ownership">Struct Ownership vs Field Ownership</h3>
<p>When you create a struct instance, the struct <strong>owns all of its field data</strong>[1]. This ownership relationship has important implications:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Document {
</span><span>    </span><span style="color:#bf616a;">title</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">content</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">metadata</span><span>: Vec,
</span><span>    </span><span style="color:#bf616a;">word_count</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> doc = Document {
</span><span>        title: String::from(&quot;</span><span style="color:#a3be8c;">Rust Guide</span><span>&quot;),
</span><span>        content: String::from(&quot;</span><span style="color:#a3be8c;">Learning Rust ownership...</span><span>&quot;),
</span><span>        metadata: vec![&quot;</span><span style="color:#a3be8c;">programming</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">tutorial</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>        word_count: </span><span style="color:#d08770;">3</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// The &#39;doc&#39; variable owns:
</span><span>    </span><span style="color:#a7adba;">// - The String data for title (heap-allocated)
</span><span>    </span><span style="color:#a7adba;">// - The String data for content (heap-allocated)
</span><span>    </span><span style="color:#a7adba;">// - The Vec and its String elements (heap-allocated)
</span><span>    </span><span style="color:#a7adba;">// - The usize value for word_count (stack-allocated)
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Document owns all its data: </span><span style="color:#d08770;">{:?}</span><span>&quot;, doc);
</span><span>}
</span></code></pre>
<h2 id="move-semantics-with-struct-data">Move Semantics with Struct Data</h2>
<h3 id="complete-struct-moves">Complete Struct Moves</h3>
<p>When you assign a struct to another variable or pass it to a function, <strong>ownership of the entire struct moves</strong>[3][4]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_document</span><span>(</span><span style="color:#bf616a;">doc</span><span>: Document) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Processing: </span><span style="color:#d08770;">{}</span><span>&quot;, doc.title);
</span><span>    </span><span style="color:#a7adba;">// doc is owned by this function
</span><span>    </span><span style="color:#a7adba;">// It will be dropped when the function ends
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_doc = Document {
</span><span>        title: String::from(&quot;</span><span style="color:#a3be8c;">Important Document</span><span>&quot;),
</span><span>        content: String::from(&quot;</span><span style="color:#a3be8c;">Critical information here</span><span>&quot;),
</span><span>        metadata: vec![&quot;</span><span style="color:#a3be8c;">confidential</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>        word_count: </span><span style="color:#d08770;">3</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Move ownership to the function
</span><span>    </span><span style="color:#96b5b4;">process_document</span><span>(my_doc);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// my_doc is no longer accessible
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;{:?}&quot;, my_doc);  // Error: value borrowed after move
</span><span>}
</span></code></pre>
<h3 id="field-level-move-behavior">Field-Level Move Behavior</h3>
<p>The behavior of struct moves depends on the <strong>types of the individual fields</strong>[5]. Fields that implement <code>Copy</code> are copied, while non-<code>Copy</code> fields are moved:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>MixedData {
</span><span>    </span><span style="color:#bf616a;">id</span><span>: </span><span style="color:#b48ead;">u32</span><span>,           </span><span style="color:#a7adba;">// Copy type - will be copied
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,      </span><span style="color:#a7adba;">// Non-Copy type - will be moved
</span><span>    </span><span style="color:#bf616a;">score</span><span>: </span><span style="color:#b48ead;">f64</span><span>,        </span><span style="color:#a7adba;">// Copy type - will be copied
</span><span>    </span><span style="color:#bf616a;">tags</span><span>: Vec, </span><span style="color:#a7adba;">// Non-Copy type - will be moved
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> data1 = MixedData {
</span><span>        id: </span><span style="color:#d08770;">1</span><span>,
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;),
</span><span>        score: </span><span style="color:#d08770;">95.5</span><span>,
</span><span>        tags: vec![&quot;</span><span style="color:#a3be8c;">student</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">active</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Move the entire struct
</span><span>    </span><span style="color:#b48ead;">let</span><span> data2 = data1;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// data1 is completely invalidated, even though some fields are Copy types
</span><span>    </span><span style="color:#a7adba;">// This is because Rust treats the struct as a single unit
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Data2: </span><span style="color:#d08770;">{:?}</span><span>&quot;, data2);
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;Data1: {:?}&quot;, data1);  // Error: value borrowed after move
</span><span>}
</span></code></pre>
<h2 id="partial-moves-from-structs">Partial Moves from Structs</h2>
<h3 id="moving-individual-fields">Moving Individual Fields</h3>
<p>You can move <strong>individual fields</strong> out of a struct, but this creates a <strong>partially moved struct</strong>[3][6]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Container {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,      </span><span style="color:#a7adba;">// Non-Copy field
</span><span>    </span><span style="color:#bf616a;">data</span><span>: Vec,    </span><span style="color:#a7adba;">// Non-Copy field
</span><span>    </span><span style="color:#bf616a;">size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,       </span><span style="color:#a7adba;">// Copy field
</span><span>    </span><span style="color:#bf616a;">active</span><span>: </span><span style="color:#b48ead;">bool</span><span>,      </span><span style="color:#a7adba;">// Copy field
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> container = Container {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">data_container</span><span>&quot;),
</span><span>        data: vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>],
</span><span>        size: </span><span style="color:#d08770;">5</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Move individual fields
</span><span>    </span><span style="color:#b48ead;">let</span><span> extracted_name = container.name;  </span><span style="color:#a7adba;">// Move name field
</span><span>    </span><span style="color:#b48ead;">let</span><span> extracted_data = container.data;  </span><span style="color:#a7adba;">// Move data field
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Copy fields are still accessible
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Size: </span><span style="color:#d08770;">{}</span><span>&quot;, container.size);    </span><span style="color:#a7adba;">// OK - Copy type
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Active: </span><span style="color:#d08770;">{}</span><span>&quot;, container.active); </span><span style="color:#a7adba;">// OK - Copy type
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Moved fields are no longer accessible
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;Name: {}&quot;, container.name);  // Error: value borrowed after move
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;Data: {:?}&quot;, container.data); // Error: value borrowed after move
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Cannot use the whole struct anymore
</span><span>    </span><span style="color:#a7adba;">// println!(&quot;Container: {:?}&quot;, container); // Error: partially moved value
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Extracted name: </span><span style="color:#d08770;">{}</span><span>&quot;, extracted_name);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Extracted data: </span><span style="color:#d08770;">{:?}</span><span>&quot;, extracted_data);
</span><span>}
</span></code></pre>
<h3 id="safe-extraction-patterns">Safe Extraction Patterns</h3>
<p>Use <code>std::mem</code> functions for safe field extraction:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::mem;
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Container {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">extract_name</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; String {
</span><span>        mem::take(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>.name)  </span><span style="color:#a7adba;">// Replace with default (empty String)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">extract_data</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Vec {
</span><span>        mem::take(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>.data)  </span><span style="color:#a7adba;">// Replace with default (empty Vec)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">swap_name</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">new_name</span><span>: String) -&gt; String {
</span><span>        mem::replace(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>.name, new_name)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> container = Container {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">original</span><span>&quot;),
</span><span>        data: vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>],
</span><span>        size: </span><span style="color:#d08770;">3</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Safe extraction - struct remains valid
</span><span>    </span><span style="color:#b48ead;">let</span><span> old_name = container.</span><span style="color:#96b5b4;">extract_name</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> old_data = container.</span><span style="color:#96b5b4;">extract_data</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Extracted: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> and </span><span style="color:#d08770;">{:?}</span><span>&quot;, old_name, old_data);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Container still valid: </span><span style="color:#d08770;">{:?}</span><span>&quot;, container);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Swap operation
</span><span>    </span><span style="color:#b48ead;">let</span><span> previous = container.</span><span style="color:#96b5b4;">swap_name</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">new_name</span><span>&quot;));
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Previous name: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, new container: </span><span style="color:#d08770;">{:?}</span><span>&quot;, previous, container);
</span><span>}
</span></code></pre>
<h2 id="borrowing-struct-data">Borrowing Struct Data</h2>
<h3 id="immutable-borrowing">Immutable Borrowing</h3>
<p>You can <strong>borrow struct data immutably</strong> without transferring ownership[4][7]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">analyze_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;User) -&gt; String {
</span><span>    format!(&quot;</span><span style="color:#a3be8c;">User </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> years old and is </span><span style="color:#d08770;">{}</span><span>&quot;,
</span><span>            user.username,
</span><span>            user.age,
</span><span>            </span><span style="color:#b48ead;">if</span><span> user.active { &quot;</span><span style="color:#a3be8c;">active</span><span>&quot; } </span><span style="color:#b48ead;">else </span><span>{ &quot;</span><span style="color:#a3be8c;">inactive</span><span>&quot; })
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> user = User {
</span><span>        username: String::from(&quot;</span><span style="color:#a3be8c;">bob456</span><span>&quot;),
</span><span>        email: String::from(&quot;</span><span style="color:#a3be8c;">bob@example.com</span><span>&quot;),
</span><span>        age: </span><span style="color:#d08770;">25</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Borrow the struct immutably
</span><span>    </span><span style="color:#b48ead;">let</span><span> analysis = </span><span style="color:#96b5b4;">analyze_user</span><span>(&amp;user);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, analysis);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// user is still owned and accessible
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Email: </span><span style="color:#d08770;">{}</span><span>&quot;, user.email);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Can borrow multiple times
</span><span>    </span><span style="color:#b48ead;">let</span><span> analysis2 = </span><span style="color:#96b5b4;">analyze_user</span><span>(&amp;user);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Second analysis: </span><span style="color:#d08770;">{}</span><span>&quot;, analysis2);
</span><span>}
</span></code></pre>
<h3 id="mutable-borrowing">Mutable Borrowing</h3>
<p><strong>Mutable borrowing</strong> allows modification while maintaining ownership[4][7]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">update_user_info</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> User) {
</span><span>    user.age += </span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#a7adba;">// Birthday increment
</span><span>    user.email = String::from(&quot;</span><span style="color:#a3be8c;">updated@example.com</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> user.username.</span><span style="color:#96b5b4;">starts_with</span><span>(&quot;</span><span style="color:#a3be8c;">temp_</span><span>&quot;) {
</span><span>        user.active = </span><span style="color:#d08770;">false</span><span>;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">deactivate_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> User) {
</span><span>    user.active = </span><span style="color:#d08770;">false</span><span>;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">User </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> deactivated</span><span>&quot;, user.username);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> user = User {
</span><span>        username: String::from(&quot;</span><span style="color:#a3be8c;">charlie789</span><span>&quot;),
</span><span>        email: String::from(&quot;</span><span style="color:#a3be8c;">charlie@example.com</span><span>&quot;),
</span><span>        age: </span><span style="color:#d08770;">28</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Before update: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Mutable borrow for modification
</span><span>    </span><span style="color:#96b5b4;">update_user_info</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> user);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">After update: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Another mutable borrow (previous borrow has ended)
</span><span>    </span><span style="color:#96b5b4;">deactivate_user</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> user);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">After deactivation: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>}
</span></code></pre>
<h2 id="field-level-borrowing">Field-Level Borrowing</h2>
<h3 id="independent-field-borrowing">Independent Field Borrowing</h3>
<p>Rust allows <strong>borrowing different fields independently</strong>[8], enabling flexible access patterns:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Database {
</span><span>    </span><span style="color:#bf616a;">connection_string</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">query_cache</span><span>: Vec,
</span><span>    </span><span style="color:#bf616a;">connection_count</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">is_connected</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process_queries</span><span>(</span><span style="color:#bf616a;">queries</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Vec, </span><span style="color:#bf616a;">connection_info</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) {
</span><span>    queries.</span><span style="color:#96b5b4;">push</span><span>(format!(&quot;</span><span style="color:#a3be8c;">SELECT * FROM users WHERE connection = &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39;</span><span>&quot;, connection_info));
</span><span>    queries.</span><span style="color:#96b5b4;">push</span><span>(&quot;</span><span style="color:#a3be8c;">UPDATE stats SET last_access = NOW()</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> db = Database {
</span><span>        connection_string: String::from(&quot;</span><span style="color:#a3be8c;">postgres://localhost:5432/mydb</span><span>&quot;),
</span><span>        query_cache: Vec::new(),
</span><span>        connection_count: </span><span style="color:#d08770;">0</span><span>,
</span><span>        is_connected: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Borrow different fields independently
</span><span>    </span><span style="color:#96b5b4;">process_queries</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> db.query_cache, &amp;db.connection_string);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Can access other fields while borrows are active
</span><span>    db.connection_count += </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Database state: </span><span style="color:#d08770;">{:?}</span><span>&quot;, db);
</span><span>}
</span></code></pre>
<h3 id="field-borrowing-patterns">Field Borrowing Patterns</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>Database {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_connection_info</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span>{
</span><span>        &amp;</span><span style="color:#bf616a;">self</span><span>.connection_string
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add_query</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">query</span><span>: String) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.query_cache.</span><span style="color:#96b5b4;">push</span><span>(query);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">is_active</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.is_connected &amp;&amp; </span><span style="color:#bf616a;">self</span><span>.connection_count &gt; </span><span style="color:#d08770;">0
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method that borrows multiple fields
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">status_report</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; String {
</span><span>        format!(
</span><span>            &quot;</span><span style="color:#a3be8c;">Database </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> with </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> cached queries, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> connections</span><span>&quot;,
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.is_connected { &quot;</span><span style="color:#a3be8c;">connected</span><span>&quot; } </span><span style="color:#b48ead;">else </span><span>{ &quot;</span><span style="color:#a3be8c;">disconnected</span><span>&quot; },
</span><span>            </span><span style="color:#bf616a;">self</span><span>.query_cache.</span><span style="color:#96b5b4;">len</span><span>(),
</span><span>            </span><span style="color:#bf616a;">self</span><span>.connection_count
</span><span>        )
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Method that needs mutable access to specific fields
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">reset_cache</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.query_cache.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Query cache cleared</span><span>&quot;);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> db = Database {
</span><span>        connection_string: String::from(&quot;</span><span style="color:#a3be8c;">postgres://localhost:5432/mydb</span><span>&quot;),
</span><span>        query_cache: vec![&quot;</span><span style="color:#a3be8c;">SELECT 1</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>        connection_count: </span><span style="color:#d08770;">3</span><span>,
</span><span>        is_connected: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Multiple borrows of different aspects
</span><span>    </span><span style="color:#b48ead;">let</span><span> info = db.</span><span style="color:#96b5b4;">get_connection_info</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> active = db.</span><span style="color:#96b5b4;">is_active</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> report = db.</span><span style="color:#96b5b4;">status_report</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Info: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, Active: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, Report: </span><span style="color:#d08770;">{}</span><span>&quot;, info, active, report);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Mutable operation
</span><span>    db.</span><span style="color:#96b5b4;">add_query</span><span>(&quot;</span><span style="color:#a3be8c;">SELECT * FROM products</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>    db.</span><span style="color:#96b5b4;">reset_cache</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Final state: </span><span style="color:#d08770;">{:?}</span><span>&quot;, db);
</span><span>}
</span></code></pre>
<h2 id="ownership-transfer-patterns">Ownership Transfer Patterns</h2>
<h3 id="function-parameter-patterns">Function Parameter Patterns</h3>
<p>Different patterns for passing struct ownership to functions[4]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Pattern 1: Take ownership (move)
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">consume_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: User) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let</span><span> summary = format!(&quot;</span><span style="color:#a3be8c;">Processed user: </span><span style="color:#d08770;">{}</span><span>&quot;, user.username);
</span><span>    </span><span style="color:#a7adba;">// user is dropped at the end of this function
</span><span>    summary
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Pattern 2: Borrow immutably
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;User) -&gt; String {
</span><span>    format!(&quot;</span><span style="color:#a3be8c;">User </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> has email </span><span style="color:#d08770;">{}</span><span>&quot;, user.username, user.email)
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Pattern 3: Borrow mutably
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">modify_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> User) {
</span><span>    user.age += </span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Pattern 4: Return ownership
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_user</span><span>(</span><span style="color:#bf616a;">name</span><span>: String, </span><span style="color:#bf616a;">email</span><span>: String) -&gt; User {
</span><span>    User {
</span><span>        username: name,
</span><span>        email,
</span><span>        age: </span><span style="color:#d08770;">0</span><span>,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Pattern 5: Transform (consume and return new)
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">upgrade_user</span><span>(</span><span style="color:#bf616a;">user</span><span>: User) -&gt; User {
</span><span>    User {
</span><span>        username: format!(&quot;</span><span style="color:#a3be8c;">premium_</span><span style="color:#d08770;">{}</span><span>&quot;, user.username),
</span><span>        email: user.email,
</span><span>        age: user.age,
</span><span>        active: </span><span style="color:#d08770;">true</span><span>,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> user = </span><span style="color:#96b5b4;">create_user</span><span>(
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">testuser</span><span>&quot;),
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">test@example.com</span><span>&quot;)
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Read without taking ownership
</span><span>    </span><span style="color:#b48ead;">let</span><span> info = </span><span style="color:#96b5b4;">read_user</span><span>(&amp;user);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, info);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Modify without taking ownership
</span><span>    </span><span style="color:#96b5b4;">modify_user</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> user);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">After modification: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Transform by consuming and creating new
</span><span>    </span><span style="color:#b48ead;">let</span><span> upgraded = </span><span style="color:#96b5b4;">upgrade_user</span><span>(user);
</span><span>    </span><span style="color:#a7adba;">// user is no longer accessible
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Upgraded: </span><span style="color:#d08770;">{:?}</span><span>&quot;, upgraded);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Consume for final processing
</span><span>    </span><span style="color:#b48ead;">let</span><span> summary = </span><span style="color:#96b5b4;">consume_user</span><span>(upgraded);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, summary);
</span><span>}
</span></code></pre>
<h3 id="builder-pattern-with-ownership">Builder Pattern with Ownership</h3>
<p>Using ownership transfer in builder patterns:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Config {
</span><span>    </span><span style="color:#bf616a;">host</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">port</span><span>: </span><span style="color:#b48ead;">u16</span><span>,
</span><span>    </span><span style="color:#bf616a;">database</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">pool_size</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">timeout</span><span>: </span><span style="color:#b48ead;">u64</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>ConfigBuilder {
</span><span>    </span><span style="color:#bf616a;">config</span><span>: Config,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>ConfigBuilder {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        ConfigBuilder {
</span><span>            config: Config {
</span><span>                host: String::from(&quot;</span><span style="color:#a3be8c;">localhost</span><span>&quot;),
</span><span>                port: </span><span style="color:#d08770;">5432</span><span>,
</span><span>                database: String::from(&quot;</span><span style="color:#a3be8c;">default</span><span>&quot;),
</span><span>                pool_size: </span><span style="color:#d08770;">10</span><span>,
</span><span>                timeout: </span><span style="color:#d08770;">5000</span><span>,
</span><span>            },
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Each method takes ownership and returns ownership
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">host</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">host</span><span>: String) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.config.host = host;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">port</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">port</span><span>: </span><span style="color:#b48ead;">u16</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.config.port = port;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">database</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">database</span><span>: String) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.config.database = database;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">pool_size</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">size</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.config.pool_size = size;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">build</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; Config {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.config  </span><span style="color:#a7adba;">// Transfer ownership of the config
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> config = ConfigBuilder::new()
</span><span>        .</span><span style="color:#96b5b4;">host</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">production.server.com</span><span>&quot;))
</span><span>        .</span><span style="color:#96b5b4;">port</span><span>(</span><span style="color:#d08770;">443</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">database</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">prod_db</span><span>&quot;))
</span><span>        .</span><span style="color:#96b5b4;">pool_size</span><span>(</span><span style="color:#d08770;">50</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">build</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Built config: </span><span style="color:#d08770;">{:?}</span><span>&quot;, config);
</span><span>}
</span></code></pre>
<h2 id="advanced-ownership-patterns">Advanced Ownership Patterns</h2>
<h3 id="option-and-result-with-struct-ownership">Option and Result with Struct Ownership</h3>
<p>Managing optional struct ownership:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Connection {
</span><span>    </span><span style="color:#bf616a;">id</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">host</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">status</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>ConnectionManager {
</span><span>    </span><span style="color:#bf616a;">active_connection</span><span>: Option,
</span><span>    </span><span style="color:#bf616a;">backup_connection</span><span>: Option,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>ConnectionManager {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        ConnectionManager {
</span><span>            active_connection: None,
</span><span>            backup_connection: None,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">connect</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">host</span><span>: String) -&gt; Result {
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.active_connection.</span><span style="color:#96b5b4;">is_some</span><span>() {
</span><span>            </span><span style="color:#b48ead;">return </span><span>Err(&quot;</span><span style="color:#a3be8c;">Already connected</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> connection = Connection {
</span><span>            id: </span><span style="color:#d08770;">1</span><span>,
</span><span>            host,
</span><span>            status: &quot;</span><span style="color:#a3be8c;">connected</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#bf616a;">self</span><span>.active_connection = Some(connection);
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">disconnect</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.active_connection.</span><span style="color:#96b5b4;">take</span><span>()  </span><span style="color:#a7adba;">// Takes ownership out of Option
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">failover</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Result {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(backup) = </span><span style="color:#bf616a;">self</span><span>.backup_connection.</span><span style="color:#96b5b4;">take</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> old_connection = </span><span style="color:#bf616a;">self</span><span>.active_connection.</span><span style="color:#96b5b4;">replace</span><span>(backup);
</span><span>            </span><span style="color:#b48ead;">if let </span><span>Some(old) = old_connection {
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">Failed over from connection </span><span style="color:#d08770;">{}</span><span>&quot;, old.id);
</span><span>            }
</span><span>            Ok(())
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            Err(&quot;</span><span style="color:#a3be8c;">No backup connection available</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>())
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_connection_info</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Option {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.active_connection.</span><span style="color:#96b5b4;">as_ref</span><span>()  </span><span style="color:#a7adba;">// Borrow without taking ownership
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> manager = ConnectionManager::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Establish connection
</span><span>    manager.</span><span style="color:#96b5b4;">connect</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">primary.server.com</span><span>&quot;)).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Read connection info
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(conn) = manager.</span><span style="color:#96b5b4;">get_connection_info</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Connected to: </span><span style="color:#d08770;">{}</span><span>&quot;, conn.host);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Disconnect and take ownership
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(old_conn) = manager.</span><span style="color:#96b5b4;">disconnect</span><span>() {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Disconnected from: </span><span style="color:#d08770;">{}</span><span>&quot;, old_conn.host);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="shared-ownership-with-smart-pointers">Shared Ownership with Smart Pointers</h3>
<p>When multiple owners are needed, use smart pointers[9][10]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::rc::Rc;
</span><span style="color:#b48ead;">use </span><span>std::sync::Arc;
</span><span style="color:#b48ead;">use </span><span>std::cell::RefCell;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>SharedResource {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">data</span><span>: Vec,
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Single-threaded shared ownership
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">single_threaded_sharing</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> resource = Rc::new(SharedResource {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">shared_data</span><span>&quot;),
</span><span>        data: vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>],
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ref1 = Rc::clone(&amp;resource);
</span><span>    </span><span style="color:#b48ead;">let</span><span> ref2 = Rc::clone(&amp;resource);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Resource name: </span><span style="color:#d08770;">{}</span><span>&quot;, ref1.name);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Resource data: </span><span style="color:#d08770;">{:?}</span><span>&quot;, ref2.data);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Reference count: </span><span style="color:#d08770;">{}</span><span>&quot;, Rc::strong_count(&amp;resource));
</span><span>
</span><span>    </span><span style="color:#a7adba;">// All references share the same data
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Multi-threaded shared ownership
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">multi_threaded_sharing</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> resource = Arc::new(SharedResource {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">thread_safe_data</span><span>&quot;),
</span><span>        data: vec![</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">20</span><span>, </span><span style="color:#d08770;">30</span><span>],
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> handles: Vec = (</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">3</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">i</span><span>| {
</span><span>            </span><span style="color:#b48ead;">let</span><span> resource_clone = Arc::clone(&amp;resource);
</span><span>            std::thread::spawn(</span><span style="color:#b48ead;">move </span><span>|| {
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">Thread </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> accessing: </span><span style="color:#d08770;">{}</span><span>&quot;, i, resource_clone.name);
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">Thread </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> sees data: </span><span style="color:#d08770;">{:?}</span><span>&quot;, i, resource_clone.data);
</span><span>            })
</span><span>        })
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> handle in handles {
</span><span>        handle.</span><span style="color:#96b5b4;">join</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Interior mutability with shared ownership
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">shared_mutable_ownership</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> resource = Rc::new(RefCell::new(SharedResource {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">mutable_shared</span><span>&quot;),
</span><span>        data: vec![</span><span style="color:#d08770;">100</span><span>, </span><span style="color:#d08770;">200</span><span>],
</span><span>    }));
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ref1 = Rc::clone(&amp;resource);
</span><span>    </span><span style="color:#b48ead;">let</span><span> ref2 = Rc::clone(&amp;resource);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Mutate through one reference
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> borrowed = ref1.</span><span style="color:#96b5b4;">borrow_mut</span><span>();
</span><span>        borrowed.data.</span><span style="color:#96b5b4;">push</span><span>(</span><span style="color:#d08770;">300</span><span>);
</span><span>        borrowed.name.</span><span style="color:#96b5b4;">push_str</span><span>(&quot;</span><span style="color:#a3be8c;">_modified</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Read through another reference
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let</span><span> borrowed = ref2.</span><span style="color:#96b5b4;">borrow</span><span>();
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Modified resource: </span><span style="color:#d08770;">{:?}</span><span>&quot;, *borrowed);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">=== Single-threaded sharing ===</span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">single_threaded_sharing</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">=== Multi-threaded sharing ===</span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">multi_threaded_sharing</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">=== Shared mutable ownership ===</span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">shared_mutable_ownership</span><span>();
</span><span>}
</span></code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="zero-cost-abstractions">Zero-Cost Abstractions</h3>
<p>Rust's ownership system for structs is implemented as <strong>zero-cost abstractions</strong>[9]:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::time::Instant;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Point3D {
</span><span>    </span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>    </span><span style="color:#bf616a;">y</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>    </span><span style="color:#bf616a;">z</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Point3D {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">y</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">z</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        Point3D { x, y, z }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">distance_from_origin</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">f64 </span><span>{
</span><span>        (</span><span style="color:#bf616a;">self</span><span>.x * </span><span style="color:#bf616a;">self</span><span>.x + </span><span style="color:#bf616a;">self</span><span>.y * </span><span style="color:#bf616a;">self</span><span>.y + </span><span style="color:#bf616a;">self</span><span>.z * </span><span style="color:#bf616a;">self</span><span>.z).</span><span style="color:#96b5b4;">sqrt</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// This compiles to the same code as manual field access
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">scale</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">factor</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.x *= factor;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.y *= factor;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.z *= factor;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">benchmark_ownership_patterns</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> point = Point3D::new(</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">2.0</span><span>, </span><span style="color:#d08770;">3.0</span><span>);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = Instant::now();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Ownership transfers are zero-cost
</span><span>    </span><span style="color:#b48ead;">let</span><span> scaled = point.</span><span style="color:#96b5b4;">scale</span><span>(</span><span style="color:#d08770;">2.0</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> distance = scaled.</span><span style="color:#96b5b4;">distance_from_origin</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> duration = start.</span><span style="color:#96b5b4;">elapsed</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Distance: </span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;">, computed in: </span><span style="color:#d08770;">{:?}</span><span>&quot;, distance, duration);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">benchmark_ownership_patterns</span><span>();
</span><span>}
</span></code></pre>
<h3 id="memory-layout-optimization">Memory Layout Optimization</h3>
<p>Struct field ordering affects memory usage:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::mem;
</span><span>
</span><span style="color:#a7adba;">// Optimized layout - fields ordered by size
</span><span>#[</span><span style="color:#bf616a;">repr</span><span>(C)]
</span><span style="color:#b48ead;">struct </span><span>OptimizedStruct {
</span><span>    </span><span style="color:#bf616a;">large_data</span><span>: [</span><span style="color:#b48ead;">u8</span><span>; 16],    </span><span style="color:#a7adba;">// 16 bytes
</span><span>    </span><span style="color:#bf616a;">medium_data</span><span>: </span><span style="color:#b48ead;">u64</span><span>,        </span><span style="color:#a7adba;">// 8 bytes
</span><span>    </span><span style="color:#bf616a;">small_data</span><span>: </span><span style="color:#b48ead;">u32</span><span>,         </span><span style="color:#a7adba;">// 4 bytes
</span><span>    </span><span style="color:#bf616a;">tiny_data</span><span>: </span><span style="color:#b48ead;">u16</span><span>,          </span><span style="color:#a7adba;">// 2 bytes
</span><span>    </span><span style="color:#bf616a;">flag</span><span>: </span><span style="color:#b48ead;">bool</span><span>,              </span><span style="color:#a7adba;">// 1 byte
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Unoptimized layout - random ordering
</span><span style="color:#b48ead;">struct </span><span>UnoptimizedStruct {
</span><span>    </span><span style="color:#bf616a;">flag</span><span>: </span><span style="color:#b48ead;">bool</span><span>,              </span><span style="color:#a7adba;">// 1 byte + 7 padding
</span><span>    </span><span style="color:#bf616a;">large_data</span><span>: [</span><span style="color:#b48ead;">u8</span><span>; 16],    </span><span style="color:#a7adba;">// 16 bytes
</span><span>    </span><span style="color:#bf616a;">tiny_data</span><span>: </span><span style="color:#b48ead;">u16</span><span>,          </span><span style="color:#a7adba;">// 2 bytes + 6 padding
</span><span>    </span><span style="color:#bf616a;">medium_data</span><span>: </span><span style="color:#b48ead;">u64</span><span>,        </span><span style="color:#a7adba;">// 8 bytes
</span><span>    </span><span style="color:#bf616a;">small_data</span><span>: </span><span style="color:#b48ead;">u32</span><span>,         </span><span style="color:#a7adba;">// 4 bytes + 4 padding
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Optimized struct size: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, mem::size_of::());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Unoptimized struct size: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, mem::size_of::());
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> optimized = OptimizedStruct {
</span><span>        large_data: [</span><span style="color:#d08770;">0</span><span>; </span><span style="color:#d08770;">16</span><span>],
</span><span>        medium_data: </span><span style="color:#d08770;">42</span><span>,
</span><span>        small_data: </span><span style="color:#d08770;">100</span><span>,
</span><span>        tiny_data: </span><span style="color:#d08770;">5</span><span>,
</span><span>        flag: </span><span style="color:#d08770;">true</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Ownership and field access have identical performance
</span><span>    </span><span style="color:#a7adba;">// regardless of struct layout
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Optimized flag: </span><span style="color:#d08770;">{}</span><span>&quot;, optimized.flag);
</span><span>}
</span></code></pre>
<h2 id="best-practices-for-struct-ownership">Best Practices for Struct Ownership</h2>
<h3 id="design-guidelines">Design Guidelines</h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// 1. Prefer owned data in struct fields
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>GoodUser {
</span><span>    </span><span style="color:#bf616a;">username</span><span>: String,    </span><span style="color:#a7adba;">// Owned - no lifetime constraints
</span><span>    </span><span style="color:#bf616a;">email</span><span>: String,       </span><span style="color:#a7adba;">// Owned - no lifetime constraints
</span><span>    </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">active</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// 2. Use references only when necessary (requires lifetimes)
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>UserRef {
</span><span>    </span><span style="color:#bf616a;">username</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>,   </span><span style="color:#a7adba;">// Borrowed - requires lifetime annotation
</span><span>    </span><span style="color:#bf616a;">email</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>,      </span><span style="color:#a7adba;">// Borrowed - requires lifetime annotation
</span><span>    </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">active</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// 3. Provide both owned and borrowed APIs
</span><span style="color:#b48ead;">impl </span><span>GoodUser {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">username</span><span>: String, </span><span style="color:#bf616a;">email</span><span>: String, </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        GoodUser {
</span><span>            username,
</span><span>            email,
</span><span>            age,
</span><span>            active: </span><span style="color:#d08770;">true</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Borrow for read-only operations
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">display_info</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; String {
</span><span>        format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">) - Age: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.username, </span><span style="color:#bf616a;">self</span><span>.email, </span><span style="color:#bf616a;">self</span><span>.age)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Take ownership for transformations
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">into_inactive</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.active = </span><span style="color:#d08770;">false</span><span>;
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Mutable borrow for modifications
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">update_email</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">new_email</span><span>: String) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.email = new_email;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// 4. Use builder pattern for complex construction
</span><span style="color:#b48ead;">struct </span><span>UserBuilder {
</span><span>    </span><span style="color:#bf616a;">username</span><span>: Option,
</span><span>    </span><span style="color:#bf616a;">email</span><span>: Option,
</span><span>    </span><span style="color:#bf616a;">age</span><span>: Option,
</span><span>    </span><span style="color:#bf616a;">active</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>UserBuilder {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        UserBuilder {
</span><span>            username: None,
</span><span>            email: None,
</span><span>            age: None,
</span><span>            active: </span><span style="color:#d08770;">true</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">username</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">username</span><span>: String) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.username = Some(username);
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">email</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">email</span><span>: String) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.email = Some(email);
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">age</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.age = Some(age);
</span><span>        </span><span style="color:#bf616a;">self
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">build</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; Result {
</span><span>        </span><span style="color:#b48ead;">let</span><span> username = </span><span style="color:#bf616a;">self</span><span>.username.</span><span style="color:#96b5b4;">ok_or</span><span>(&quot;</span><span style="color:#a3be8c;">Username is required</span><span>&quot;)?;
</span><span>        </span><span style="color:#b48ead;">let</span><span> email = </span><span style="color:#bf616a;">self</span><span>.email.</span><span style="color:#96b5b4;">ok_or</span><span>(&quot;</span><span style="color:#a3be8c;">Email is required</span><span>&quot;)?;
</span><span>        </span><span style="color:#b48ead;">let</span><span> age = </span><span style="color:#bf616a;">self</span><span>.age.</span><span style="color:#96b5b4;">ok_or</span><span>(&quot;</span><span style="color:#a3be8c;">Age is required</span><span>&quot;)?;
</span><span>
</span><span>        Ok(GoodUser {
</span><span>            username,
</span><span>            email,
</span><span>            age,
</span><span>            active: </span><span style="color:#bf616a;">self</span><span>.active,
</span><span>        })
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#a7adba;">// Using owned data (preferred)
</span><span>    </span><span style="color:#b48ead;">let</span><span> user = GoodUser::new(
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">alice</span><span>&quot;),
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">alice@example.com</span><span>&quot;),
</span><span>        </span><span style="color:#d08770;">30
</span><span>    );
</span><span>
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, user.</span><span style="color:#96b5b4;">display_info</span><span>());
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Using builder pattern
</span><span>    </span><span style="color:#b48ead;">let</span><span> user2 = UserBuilder::new()
</span><span>        .</span><span style="color:#96b5b4;">username</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">bob</span><span>&quot;))
</span><span>        .</span><span style="color:#96b5b4;">email</span><span>(String::from(&quot;</span><span style="color:#a3be8c;">bob@example.com</span><span>&quot;))
</span><span>        .</span><span style="color:#96b5b4;">age</span><span>(</span><span style="color:#d08770;">25</span><span>)
</span><span>        .</span><span style="color:#96b5b4;">build</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Built user: </span><span style="color:#d08770;">{:?}</span><span>&quot;, user2);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Transform by taking ownership
</span><span>    </span><span style="color:#b48ead;">let</span><span> inactive_user = user.</span><span style="color:#96b5b4;">into_inactive</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Inactive user: </span><span style="color:#d08770;">{:?}</span><span>&quot;, inactive_user);
</span><span>}
</span></code></pre>
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<h3 id="essential-ownership-rules-for-structs"><strong>Essential Ownership Rules for Structs</strong></h3>
<ul>
<li><strong>Structs own all their field data</strong> by default[1][2]</li>
<li><strong>Moving a struct moves all its fields</strong>, regardless of individual field Copy status[3][5]</li>
<li><strong>Partial moves</strong> from structs invalidate the original struct instance</li>
<li><strong>Field-level borrowing</strong> allows independent access to different struct fields[8]</li>
</ul>
<h3 id="memory-safety-guarantees"><strong>Memory Safety Guarantees</strong></h3>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// Rust prevents these common errors at compile time:
</span><span style="color:#a7adba;">// 1. Use after move
</span><span style="color:#a7adba;">// 2. Double free
</span><span style="color:#a7adba;">// 3. Dangling pointers
</span><span style="color:#a7adba;">// 4. Data races in concurrent access
</span></code></pre>
<h3 id="performance-characteristics"><strong>Performance Characteristics</strong></h3>
<ul>
<li><strong>Zero-cost abstractions</strong> - ownership checking happens at compile time[9]</li>
<li><strong>No runtime overhead</strong> for ownership transfer operations</li>
<li><strong>Optimal memory layout</strong> when fields are properly ordered</li>
<li><strong>Predictable deallocation</strong> when owners go out of scope</li>
</ul>
<h3 id="best-practices-summary"><strong>Best Practices Summary</strong></h3>
<ul>
<li><strong>Prefer owned types</strong> (<code>String</code>, <code>Vec</code>) over borrowed types (<code>&amp;str</code>, <code>&amp;[T]</code>) in struct fields</li>
<li><strong>Use appropriate borrowing patterns</strong> for different access needs</li>
<li><strong>Design APIs that minimize unnecessary ownership transfers</strong></li>
<li><strong>Leverage smart pointers</strong> (<code>Rc</code>, <code>Arc</code>) for shared ownership when needed[10]</li>
<li><strong>Document ownership semantics</strong> clearly in public APIs</li>
</ul>
<p>Understanding ownership of struct data is crucial for writing efficient, safe Rust code. <strong>Rust's ownership system provides memory safety without runtime overhead</strong> while giving developers fine-grained control over data access patterns and lifecycle management.</p>
<ol>
<li>https://www.rustfinity.com/learn/rust/structs/structs-and-ownership</li>
<li>https://doc.rust-lang.org/book/ch05-01-defining-structs.html</li>
<li>https://alexanderobregon.substack.com/p/ownership-in-rust-structs-and-what</li>
<li>https://dev.to/sgchris/understanding-ownership-with-structs-and-functions-3bbd</li>
<li>https://stackoverflow.com/questions/64391055/struct-ownership</li>
<li>https://users.rust-lang.org/t/how-to-take-ownership-of-a-field-of-uniquely-borrowed-struct/16169</li>
<li>https://dev.to/leapcell/rust-ownership-and-borrowing-explained-22l6</li>
<li>https://users.rust-lang.org/t/method-borrowing-a-structs-field-and-not-the-struct-as-a-whole/67945</li>
<li>https://hackernoon.com/rusts-ownership-system-10-things-you-should-know</li>
<li>https://www.linkedin.com/pulse/managing-shared-ownership-structs-rust-rct-vs-roberto-trunfio-xjusf</li>
<li>https://www.reddit.com/r/rust/comments/tf9xv4/question_about_struct_ownership/</li>
<li>https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</li>
<li>https://stackoverflow.com/questions/69881785/rust-ownership-borrowing-in-struct-constructors</li>
<li>https://www.w3schools.com/rust/rust_ownership.php</li>
<li>https://users.rust-lang.org/t/struct-owning-a-slice-best-practice/96021</li>
<li>https://users.rust-lang.org/t/what-exactly-is-moving-of-ownership-means-in-rust/93504</li>
<li>https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</li>
<li>https://doc.rust-lang.org/rust-by-example/scope/move.html</li>
<li>https://yoyo-code.com/indirect-ownership-and-self-borrow/</li>
<li>https://dev.to/francescoxx/ownership-in-rust-57j2</li>
<li>https://stackoverflow.com/questions/44494888/move-ownership-of-a-member-from-one-struct-to-another</li>
<li>https://educatedguesswork.org/posts/memory-management-4/</li>
<li>https://users.rust-lang.org/t/behind-the-scenes-how-does-rust-move-structs/99229</li>
<li>https://www.risein.com/courses/rust-programming/ownership-concept</li>
</ol>

    
        </div>

    </article>
</main>


    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/elasticlunr.min.js" defer></script>
    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/search_index.en.js" defer></script>
<script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/js.js" defer></script>

</body>
</html>
