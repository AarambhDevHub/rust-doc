<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://aarambhdevhub.github.io/rust-doc/main.css">
    <link rel="icon" href="https://www.rust-lang.org/static/images/favicon-16x16.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> Rust Programming Course! | Custom Iterator Implementations </title>
</head>
<body>

<main>
    
    <nav>
            <a href="https:&#x2F;&#x2F;aarambhdevhub.github.io&#x2F;rust-doc&#x2F;">
                        <img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="logo"/>
                    </a>
                <!-- -->

            <a href="javascript:void(0);" onclick="burger()" id="mobile" class="ms-Icon--GlobalNavButton"></a>
            <div id="trees">
                <input class="tree-toggle" type="checkbox" id="day-1-introduction"
                           />
                    <label class="tree-toggle-label"
                           for="day-1-introduction">Day 1: Introduction</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-1/">What is Rust and why use it?</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-2/">Installing Rust Toolchain (rustup, cargo)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-3/">Setting up Development (VS Code + Hello World)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 1/chapter-4/">Understanding Cargo Project Structure</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-2-basic-syntax-variables"
                           />
                    <label class="tree-toggle-label"
                           for="day-2-basic-syntax-variables">Day 2: Basic Syntax &amp; Variables</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-1/">Variables and Mutability in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-2/">Data Types in Rust: Integers, Floats, Booleans, and Characters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-3/">Constants vs Variables</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-4/">Understanding Shadowing in Rust: A Practical Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 2/chapter-5/">Basic Input&#x2F;Output</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-3-functions-control-flow"
                           />
                    <label class="tree-toggle-label"
                           for="day-3-functions-control-flow">Day 3: Functions &amp; Control Flow</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-1/">Function Syntax and Parameters in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-2/">Return Values and Expressions vs Statements</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-3/">If&#x2F;Else Statements in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-4/">Match Expressions in Rust: Powerful Pattern Matching</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 3/chapter-5/">Loops in Rust: loop, while, for Explained</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-4-data-types-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-4-data-types-deep-dive">Day 4: Data Types Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-1/">Compound Types (Tuples, Arrays)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-2/">String vs &amp;str in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-3/">Vector Basics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-4/">Type Annotations and Inference in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 4/chapter-5/">Practical Rust Exercises</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-5-practice-review"
                           />
                    <label class="tree-toggle-label"
                           for="day-5-practice-review">Day 5: Practice &amp; Review</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 5/chapter-1/">Day 5: Practice &amp; Review</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-6-ownership-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-6-ownership-fundamentals">Day 6: Ownership Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-1/">Ownership in Rust: A Detailed Guide</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-2/">Stack vs Heap in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-3/">Understanding Ownership in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-4/">Move Semantics in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 6/chapter-5/">Copy Trait in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-7-references-borrowing"
                           />
                    <label class="tree-toggle-label"
                           for="day-7-references-borrowing">Day 7: References &amp; Borrowing</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-1/">Immutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-2/">Mutable References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-3/">Borrowing Rules</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-4/">Reference Lifetime Basics</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 7/chapter-5/">Common Borrowing Errors and Solutions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-8-slices"
                           />
                    <label class="tree-toggle-label"
                           for="day-8-slices">Day 8: Slices</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-1/">String Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-2/">Array Slices</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-3/">Slice Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-4/">Practical Applications</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 8/chapter-5/">Memory Safety Benefits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-9-advanced-ownership"
                           />
                    <label class="tree-toggle-label"
                           for="day-9-advanced-ownership">Day 9: Advanced Ownership</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-1/">Clone Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-2/">Drop Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-3/">RAII Pattern</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-4/">Memory Management Comparison with Other Languages</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 9/chapter-5/">Best Practices (Advanced Ownership)</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-10-ownership-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-10-ownership-practice">Day 10: Ownership Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-1/">Complex Ownership Scenarios</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-2/">Debugging Ownership Errors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-3/">Code Refactoring Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 10/chapter-4/">Group Problem-Solving</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-11-structs-basics"
                           />
                    <label class="tree-toggle-label"
                           for="day-11-structs-basics">Day 11: Structs Basics</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-1/">Defining and Instantiating Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-2/">Field Access and Modification</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-3/">Tuple Structs and Unit Structs</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-4/">Struct Update Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 11/chapter-5/">Ownership of Struct Data</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-12-methods-associated-functions"
                           />
                    <label class="tree-toggle-label"
                           for="day-12-methods-associated-functions">Day 12: Methods &amp; Associated Functions</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-1/">Implementing Methods with impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-2/">&amp;self, &amp;mut self, and self</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-3/">Associated Functions (like Constructors)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-4/">Multiple impl Blocks</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 12/chapter-5/">Method Chaining</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-13-advanced-struct-concepts"
                           />
                    <label class="tree-toggle-label"
                           for="day-13-advanced-struct-concepts">Day 13: Advanced Struct Concepts</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-1/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-2/">Debug Trait and Custom Formatting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-3/">Builder Pattern Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-4/">Struct Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 13/chapter-5/">Best Practices for Struct Design</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-14-enums-pattern-matching"
                           />
                    <label class="tree-toggle-label"
                           for="day-14-enums-pattern-matching">Day 14: Enums &amp; Pattern Matching</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-1/">Defining Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-2/">Enum Variants with Data</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-3/">Option&lt;T&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-4/">Result&lt;T, E&gt; Enum in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 14/chapter-5/">Advanced Match Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-15-practice-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-15-practice-project">Day 15: Practice Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 15/chapter-1/">Building a Simple CLI Calculator in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-16-vectors"
                           />
                    <label class="tree-toggle-label"
                           for="day-16-vectors">Day 16: Vectors</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-1/">Creating and Updating Vectors</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-2/">Vector Methods: push, pop, iter</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-3/">Accessing Vector Elements Safely</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-4/">Vector of Different Types with Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 16/chapter-5/">Performance Considerations</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-17-hashmaps-other-collections"
                           />
                    <label class="tree-toggle-label"
                           for="day-17-hashmaps-other-collections">Day 17: HashMaps &amp; Other Collections</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-1/">HashMap Creation and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-2/">Keys and Values Ownership</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-3/">HashMap Methods and Iteration</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-4/">When to Use Different Collections</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 17/chapter-5/">BTreeMap Introduction</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-18-error-handling"
                           />
                    <label class="tree-toggle-label"
                           for="day-18-error-handling">Day 18: Error Handling</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-1/">Panic! and When to Use It</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-2/">Result&lt;T, E&gt; in Depth</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-3/">The ? Operator in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-4/">Creating Custom Error Types in Rust</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 18/chapter-5/">Error Propagation Patterns in Rust</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-19-strings-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-19-strings-deep-dive">Day 19: Strings Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-1/">String vs &amp;str Revisited</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-2/">String Methods and Manipulation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-5/">Performance Considerations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-3/">UTF-8 and Character Encoding</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 19/chapter-4/">String Concatenation Techniques</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-20-mini-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-20-mini-project">Day 20: Mini Project</label>

                    <ul class="subtree">
                        </ul>
                <input class="tree-toggle" type="checkbox" id="day-21-generic-functions-structs"
                           />
                    <label class="tree-toggle-label"
                           for="day-21-generic-functions-structs">Day 21: Generic Functions &amp; Structs</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-1/">Generic Function Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-2/">Generic Structs and Enums</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-3/">Type Parameters and Constraints</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-4/">Monomorphization Concept</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 21/chapter-5/">Generic Collections</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-22-traits-fundamentals"
                           />
                    <label class="tree-toggle-label"
                           for="day-22-traits-fundamentals">Day 22: Traits Fundamentals</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-1/">Defining Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-2/">Implementing Traits for Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-3/">Default Implementations</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-4/">Trait as Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 22/chapter-5/">Trait Bounds</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-23-advanced-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-23-advanced-traits">Day 23: Advanced Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-1/">Trait Objects and Dynamic Dispatch</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-2/">Supertraits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-3/">Associated Types</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-4/">Orphan Rule</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 23/chapter-5/">Coherence Rules</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-24-standard-library-traits"
                           />
                    <label class="tree-toggle-label"
                           for="day-24-standard-library-traits">Day 24: Standard Library Traits</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-1/">Iterator Trait</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-2/">From and Into Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-3/">Display and Debug Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-4/">Clone and Copy Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 24/chapter-5/">PartialEq and Eq Traits</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-25-trait-practice"
                           />
                    <label class="tree-toggle-label"
                           for="day-25-trait-practice">Day 25: Trait Practice</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-1/">Custom Trait Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-2/">Generic Programming Exercises</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-3/">Trait Object Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 25/chapter-4/">Performance Implications</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-26-lifetime-annotations"
                           />
                    <label class="tree-toggle-label"
                           for="day-26-lifetime-annotations">Day 26: Lifetime Annotations</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-1/">Why Lifetimes Exist</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-2/">Lifetime Annotation Syntax</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-3/">Function Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-4/">Struct Lifetime Parameters</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 26/chapter-5/">Lifetime Elision Rules</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-27-advanced-lifetimes"
                           />
                    <label class="tree-toggle-label"
                           for="day-27-advanced-lifetimes">Day 27: Advanced Lifetimes</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-1/">Static Lifetime</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-2/">Lifetime Subtyping</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-3/">Higher-Ranked Trait Bounds</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-4/">Common Lifetime Patterns</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 27/chapter-5/">Debugging Lifetime Errors</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-28-smart-pointers"
                           />
                    <label class="tree-toggle-label"
                           for="day-28-smart-pointers">Day 28: Smart Pointers</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-1/">Box&lt;T&gt; for Heap Allocation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-2/">Rc&lt;T&gt; for Reference Counting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-3/">RefCell&lt;T&gt; for Interior Mutability</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-4/">Weak&lt;T&gt; References</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 28/chapter-5/">Memory Leak Prevention</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-29-concurrency-preparation"
                           />
                    <label class="tree-toggle-label"
                           for="day-29-concurrency-preparation">Day 29: Concurrency Preparation</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-1/">Arc&lt;T&gt; for Atomic Reference Counting</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-2/">Send and Sync Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-3/">Thread Safety Concepts</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-4/">Shared State Challenges</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 29/chapter-5/">Lock-Free Programming Introduction</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-30-memory-management-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-30-memory-management-project">Day 30: Memory Management Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-1/">Building a Simple Data Structure</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-2/">Using Smart Pointers Effectively</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-3/">Memory Usage Optimization</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 30/chapter-4/">Performance Benchmarking</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-31-closures"
                           />
                    <label class="tree-toggle-label"
                           for="day-31-closures">Day 31: Closures</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-1/">Closure Syntax and Usage</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-2/">Capturing Environment</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-3/">Fn, FnMut, and FnOnce Traits</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-4/">Moving Closures</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 31/chapter-5/">Closures vs Functions</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-32-iterators-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-32-iterators-deep-dive">Day 32: Iterators Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-1/">Iterator Trait Implementation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-2/">Lazy Evaluation</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-3/">Iterator Adaptors (map, filter, etc.)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-4/">Consumer Adaptors (collect, fold, etc.)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 32/chapter-5/">Custom Iterators</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-32-iterators-deep-dive"
                           />
                    <label class="tree-toggle-label"
                           for="day-32-iterators-deep-dive">Day 32: Iterators Deep Dive</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-1/">Higher-Order Functions</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-2/">Function Composition</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-3/">Immutable Data Patterns</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-4/">Functional Error Handling</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 33/chapter-5/">Performance of Functional Style</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-34-advanced-iterator-patterns"
                           checked/>
                    <label class="tree-toggle-label"
                           for="day-34-advanced-iterator-patterns">Day 34: Advanced Iterator Patterns</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-1/">Chain, Zip, Enumerate</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-2/">Flat_map and Filter_map</a>
                            </li>

                            <li class="active">
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/">Custom Iterator Implementations</a>
                            </li>

                            
                                    
                                    
                                        <ul id="toc">
                                            <li><a href="
                                                        https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#custom-iterator-implementations-in-rust-comprehensive-documentation-for-beginners">Custom Iterator Implementations in Rust: Comprehensive Documentation for Beginners</a>
                                                    <ul>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#the-professional-kitchen-dispenser-analogy-factory">The Professional Kitchen Dispenser Analogy üè≠</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#understanding-the-iterator-trait">Understanding the Iterator Trait</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#how-custom-iterators-work">How Custom Iterators Work</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#real-world-custom-iterator-applications">Real-World Custom Iterator Applications</a>
                                                                </li>
                                                            <li>
                                                                    <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-3/#summary-and-key-takeaways">Summary and Key Takeaways</a>
                                                                </li>
                                                            </ul>
                                                    </li>
                                            </ul>
                                    <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-4/">Parallel Iterators (Rayon Introduction)</a>
                            </li>

                            <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 34/chapter-5/">Iterator Performance Optimization</a>
                            </li>

                            </ul>
                <input class="tree-toggle" type="checkbox" id="day-35-functional-programming-project"
                           />
                    <label class="tree-toggle-label"
                           for="day-35-functional-programming-project">Day 35: Functional Programming Project</label>

                    <ul class="subtree">
                        <li >
                                <a href="https://aarambhdevhub.github.io/rust-doc/day 35/chapter-1/">Functional Programming Project</a>
                            </li>

                            </ul>
                </div>
        </nav>
    <article>

        <div id="on_right">
                <span id="search-ico" class="ms-Icon--Search"></span>
            </div>
            <div class="search-container">
                <input id="search" type="search" placeholder="Search as you type...">
                <div class="search-results">
                    <div class="search-results__header"></div>
                    <ul class="search-results__items"></ul>
                </div>
            </div>
        <div id="wrap">
            
        <h1 id="custom-iterator-implementations-in-rust-comprehensive-documentation-for-beginners">Custom Iterator Implementations in Rust: Comprehensive Documentation for Beginners</h1>
<p>Understanding custom iterator implementations in Rust is like learning to <strong>design specialized food dispensers for your professional restaurant kitchen</strong> - instead of manually picking ingredients one by one, you create automated systems that provide ingredients efficiently, one after another, until the supply runs out. Just as a master chef might design a custom dispenser that provides pre-portioned spices, a sequence of prepared vegetables, or a continuous flow of a sauce, Rust's <code>Iterator</code> trait allows you to define custom iterators that efficiently produce a sequence of items, one at a time, until there are no more, integrating seamlessly with Rust's powerful iterator ecosystem.</p>
<h2 id="the-professional-kitchen-dispenser-analogy-factory">The Professional Kitchen Dispenser Analogy üè≠</h2>
<h3 id="imagine-you-re-designing-automated-food-dispensers-for-your-restaurant-kitchen">Imagine You're Designing Automated Food Dispensers for Your Restaurant Kitchen</h3>
<p><strong>The Problem with Manual Item Retrieval:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// ‚ùå Manual retrieval - like picking items one by one
</span><span style="color:#b48ead;">let</span><span> ingredients = vec![&quot;</span><span style="color:#a3be8c;">tomato</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onion</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">garlic</span><span>&quot;];
</span><span style="color:#b48ead;">let mut</span><span> index = </span><span style="color:#d08770;">0</span><span>;
</span><span style="color:#b48ead;">while</span><span> index &lt; ingredients.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> item = &amp;ingredients[index];
</span><span>    </span><span style="color:#a7adba;">// Manually get item
</span><span>    index += </span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span><span style="color:#a7adba;">// Result: Verbose, error-prone, doesn&#39;t compose well
</span></code></pre>
<p><strong>The Power of Custom Iterators - Automated Dispensers:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">// ‚úÖ Automated dispenser - provides items efficiently, one by one
</span><span style="color:#b48ead;">struct </span><span>MyCustomDispenser {
</span><span>    </span><span style="color:#bf616a;">items</span><span>: Vec&lt;String&gt;,
</span><span>    </span><span style="color:#bf616a;">current_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>MyCustomDispenser {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item = String; </span><span style="color:#a7adba;">// What type of item this dispenser gives
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.current_index &lt; </span><span style="color:#bf616a;">self</span><span>.items.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> item = </span><span style="color:#bf616a;">self</span><span>.items[</span><span style="color:#bf616a;">self</span><span>.current_index].</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>            </span><span style="color:#bf616a;">self</span><span>.current_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>            Some(item)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            None </span><span style="color:#a7adba;">// Dispenser is empty
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">kitchen_dispenser_demo</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> dispenser = MyCustomDispenser {
</span><span>        items: vec![&quot;</span><span style="color:#a3be8c;">pre-chopped veggies</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">marinade portion</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>        current_index: </span><span style="color:#d08770;">0</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Seamlessly integrates with Rust&#39;s iterator system
</span><span>    </span><span style="color:#b48ead;">for</span><span> item in dispenser {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Dispensing: </span><span style="color:#d08770;">{}</span><span>&quot;, item);
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>Why Custom Iterator Implementations Are Essential:</strong></p>
<ul>
<li>üîÑ <strong>Unified interface</strong> - Integrate custom logic with Rust's powerful iterator ecosystem</li>
<li>üéØ <strong>Efficiency</strong> - Provide items on demand, no need to store entire transformed collections</li>
<li>üìù <strong>Readability</strong> - Clean, functional style code for data sequences</li>
<li>üöÄ <strong>Composability</strong> - Use with standard iterator adaptors (<code>map</code>, <code>filter</code>, <code>fold</code>, etc.)</li>
<li>‚öôÔ∏è <strong>State management</strong> - Encapsulate iteration state within the custom struct</li>
</ul>
<h2 id="understanding-the-iterator-trait">Understanding the <code>Iterator</code> Trait</h2>
<h3 id="the-blueprint-for-automated-dispensers">The Blueprint for Automated Dispensers</h3>
<p><strong>The <code>Iterator</code> trait is the core contract for defining sequences in Rust:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_iterator_trait</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">üìã Understanding the `Iterator` Trait - Dispenser Blueprints</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;70}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// The Iterator trait is the blueprint for automated food dispensers
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">‚öôÔ∏è `Iterator` Trait Definition:</span><span>&quot;);
</span><span>    println!(&quot;
</span><span style="color:#a3be8c;">   pub trait Iterator {
</span><span style="color:#a3be8c;">       // Associated type: What type of item this iterator produces
</span><span style="color:#a3be8c;">       type Item;
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       // The core method: Returns the next item or None if exhausted
</span><span style="color:#a3be8c;">       fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       // Many other default methods (e.g., map, filter, fold, sum, count)
</span><span style="color:#a3be8c;">       // These are provided for free once `next` is implemented!
</span><span style="color:#a3be8c;">   }</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 1: Implementing a Simple Counter Dispenser
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">1Ô∏è‚É£ Simple Counter Dispenser (Implements `Iterator`):</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Step 1: Define a struct to hold the iterator&#39;s state
</span><span>    </span><span style="color:#a7adba;">// Our counter needs to know its current value and where to stop
</span><span>    </span><span style="color:#b48ead;">struct </span><span>CountdownDispenser {
</span><span>        </span><span style="color:#bf616a;">current</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>        </span><span style="color:#bf616a;">end</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Step 2: Implement the `Iterator` trait for our struct
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>CountdownDispenser {
</span><span>        </span><span style="color:#a7adba;">// Associated type: This dispenser produces u32 numbers
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = </span><span style="color:#b48ead;">u32</span><span>;
</span><span>
</span><span>        </span><span style="color:#a7adba;">// The `next` method: Logic to get the next item
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.current &gt; </span><span style="color:#bf616a;">self</span><span>.end {
</span><span>                </span><span style="color:#b48ead;">let</span><span> value = </span><span style="color:#bf616a;">self</span><span>.current;
</span><span>                </span><span style="color:#bf616a;">self</span><span>.current -= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#a7adba;">// Decrement for next call
</span><span>                Some(value) </span><span style="color:#a7adba;">// Return the current value
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                None </span><span style="color:#a7adba;">// No more items (dispenser is empty)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Usage of our custom iterator
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_countdown = CountdownDispenser { current: </span><span style="color:#d08770;">5</span><span>, end: </span><span style="color:#d08770;">0 </span><span>};
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Starting countdown from 5:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> number in my_countdown {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Dispensing: </span><span style="color:#d08770;">{}</span><span>&quot;, number);
</span><span>    }
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Countdown finished!</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 2: Implementing a Fibonacci Sequence Dispenser
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">2Ô∏è‚É£ Fibonacci Sequence Dispenser (Implements `Iterator`):</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Dispenses numbers in the Fibonacci sequence (0, 1, 1, 2, 3, 5, ...)
</span><span>    </span><span style="color:#b48ead;">struct </span><span>FibonacciDispenser {
</span><span>        </span><span style="color:#bf616a;">a</span><span>: u66, </span><span style="color:#a7adba;">// Current number
</span><span>        </span><span style="color:#bf616a;">b</span><span>: u66, </span><span style="color:#a7adba;">// Next number
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>FibonacciDispenser {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = u66;
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#b48ead;">let</span><span> next_fib = </span><span style="color:#bf616a;">self</span><span>.a + </span><span style="color:#bf616a;">self</span><span>.b;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.a = </span><span style="color:#bf616a;">self</span><span>.b;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.b = next_fib;
</span><span>
</span><span>            </span><span style="color:#a7adba;">// We&#39;ll stop if numbers get too large to avoid overflow for this demo
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.a &gt; </span><span style="color:#d08770;">1_000_000 </span><span>{
</span><span>                None
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                Some(</span><span style="color:#bf616a;">self</span><span>.a)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function to create a new dispenser
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fibonacci_sequence</span><span>() -&gt; FibonacciDispenser {
</span><span>        FibonacciDispenser { a: </span><span style="color:#d08770;">0</span><span>, b: </span><span style="color:#d08770;">1 </span><span>}
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   First 10 Fibonacci numbers (starting from 1):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(i, num) in </span><span style="color:#96b5b4;">fibonacci_sequence</span><span>().</span><span style="color:#96b5b4;">take</span><span>(</span><span style="color:#d08770;">10</span><span>).</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        println!(&quot;     </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">{}</span><span>&quot;, i + </span><span style="color:#d08770;">1</span><span>, num);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 3: `IntoIterator` Trait - Making Collections Iterable
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">3Ô∏è‚É£ `IntoIterator` Trait - Making Your Struct Directly Iterable:</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚öôÔ∏è `IntoIterator` Trait Definition:</span><span>&quot;);
</span><span>    println!(&quot;
</span><span style="color:#a3be8c;">   pub trait IntoIterator {
</span><span style="color:#a3be8c;">       type Item;
</span><span style="color:#a3be8c;">       type IntoIter: Iterator&lt;Item = Self::Item&gt;; // Associated type for the actual iterator
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       fn into_iter(self) -&gt; Self::IntoIter;
</span><span style="color:#a3be8c;">   }</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// This allows your custom collection to be used directly in a `for` loop
</span><span>    </span><span style="color:#a7adba;">// (e.g., `for item in my_collection`)
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>RecipeBook {
</span><span>        </span><span style="color:#bf616a;">recipes</span><span>: Vec&lt;String&gt;,
</span><span>        </span><span style="color:#bf616a;">chef_name</span><span>: String,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// To implement IntoIterator for RecipeBook, we need an actual iterator struct
</span><span>    </span><span style="color:#a7adba;">// This will be similar to CountdownDispenser, but over Vec contents
</span><span>    </span><span style="color:#b48ead;">struct </span><span>RecipeBookIterator {
</span><span>        </span><span style="color:#bf616a;">recipes</span><span>: std::vec::IntoIter&lt;String&gt;, </span><span style="color:#a7adba;">// Iterator over the inner Vec
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>RecipeBookIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = String;
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#bf616a;">self</span><span>.recipes.</span><span style="color:#96b5b4;">next</span><span>() </span><span style="color:#a7adba;">// Delegate to Vec&#39;s iterator
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>IntoIterator </span><span style="color:#b48ead;">for </span><span>RecipeBook {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = String;
</span><span>        </span><span style="color:#b48ead;">type </span><span>IntoIter = RecipeBookIterator;
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">into_iter</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">Self::</span><span>IntoIter {
</span><span>            RecipeBookIterator {
</span><span>                recipes: </span><span style="color:#bf616a;">self</span><span>.recipes.</span><span style="color:#96b5b4;">into_iter</span><span>() </span><span style="color:#a7adba;">// Convert inner Vec into its iterator
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_cookbook = RecipeBook {
</span><span>        recipes: vec![&quot;</span><span style="color:#a3be8c;">Pizza Margherita</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Caesar Salad</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Pasta Marinara</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()],
</span><span>        chef_name: &quot;</span><span style="color:#a3be8c;">Chef Remy</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>    };
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Recipes from my cookbook:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> recipe in my_cookbook { </span><span style="color:#a7adba;">// Directly iterate thanks to IntoIterator
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     üçΩÔ∏è </span><span style="color:#d08770;">{}</span><span>&quot;, recipe);
</span><span>    }
</span><span>    </span><span style="color:#a7adba;">// my_cookbook is moved and consumed here
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">üéØ Core Concepts for Custom Iterators:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `Iterator` trait: Implemented to define `next()` method for sequential access.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `type Item`: Associated type defining what element type the iterator produces.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;`: The sole required method, managing iterator state.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `IntoIterator` trait: Implemented to allow your custom type to be used directly in `for` loops.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   üí° By implementing `Iterator`, you get all iterator adaptors for free!</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#a7adba;">// Helper trait to demonstrate to_title_case
</span><span style="color:#b48ead;">trait </span><span>ToTitleCase {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">to_title_case</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; String;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>ToTitleCase </span><span style="color:#b48ead;">for </span><span>str {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">to_title_case</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; String {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#bf616a;">c</span><span>)| {
</span><span>            </span><span style="color:#b48ead;">if</span><span> i == </span><span style="color:#d08770;">0 </span><span>{
</span><span>                c.</span><span style="color:#96b5b4;">to_uppercase</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                c.</span><span style="color:#96b5b4;">to_lowercase</span><span>().</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>            }
</span><span>        }).</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>    }
</span><span>}
</span><span style="color:#a7adba;">// Run the demonstration
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_iterator_trait</span><span>();
</span><span>}
</span></code></pre>
<h2 id="how-custom-iterators-work">How Custom Iterators Work</h2>
<h3 id="state-management-in-your-automated-dispensers">State Management in Your Automated Dispensers</h3>
<p><strong>Custom iterators store their current state within the struct and update it with each call to <code>next()</code>:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_how_custom_iterators_work</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">‚öôÔ∏è How Custom Iterators Work - State Management in Dispensers</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;70}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Custom iterators manage their internal state to dispense items one by one
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">üìã Key Mechanisms of Custom Iterators:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Internal State: The struct holds variables representing the current position or context.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `next()` Method: This method updates the internal state and returns the next item.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `Option&lt;Self::Item&gt;`: Returns `Some(item)` for success, `None` when exhausted.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Mutation: `next(&amp;mut self)` takes `&amp;mut self` because it modifies the iterator&#39;s state.</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 1: `next()` Method and State Update - Order Dispatcher
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">1Ô∏è‚É£ `next()` Method and State Update - Order Dispatcher:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Our OrderDispatcher struct will hold the list of orders and the current order to dispatch
</span><span>    </span><span style="color:#b48ead;">struct </span><span>OrderDispatcher {
</span><span>        </span><span style="color:#bf616a;">orders</span><span>: Vec&lt;String&gt;,
</span><span>        </span><span style="color:#bf616a;">current_dispatch_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>OrderDispatcher {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = String; </span><span style="color:#a7adba;">// This dispatcher dispenses String (order descriptions)
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#a7adba;">// Check if there are still orders to dispatch
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.current_dispatch_index &lt; </span><span style="color:#bf616a;">self</span><span>.orders.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>                </span><span style="color:#a7adba;">// Get the current order
</span><span>                </span><span style="color:#b48ead;">let</span><span> order = </span><span style="color:#bf616a;">self</span><span>.orders[</span><span style="color:#bf616a;">self</span><span>.current_dispatch_index].</span><span style="color:#96b5b4;">clone</span><span>(); </span><span style="color:#a7adba;">// Clone to move out of Vec
</span><span>
</span><span>                </span><span style="color:#a7adba;">// Update the state for the next call
</span><span>                </span><span style="color:#bf616a;">self</span><span>.current_dispatch_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>                </span><span style="color:#a7adba;">// Return the order, wrapped in Some
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">     [DISPATCH] Dispatching order #</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">...</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.current_dispatch_index);
</span><span>                Some(order)
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                </span><span style="color:#a7adba;">// No more orders, return None
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">     [DISPATCH] All orders dispatched. Dispenser empty.</span><span>&quot;);
</span><span>                None
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function to create an OrderDispatcher
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_order_dispatcher</span><span>(</span><span style="color:#bf616a;">orders</span><span>: Vec&lt;String&gt;) -&gt; OrderDispatcher {
</span><span>        OrderDispatcher {
</span><span>            orders,
</span><span>            current_dispatch_index: </span><span style="color:#d08770;">0</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> daily_orders = vec![
</span><span>        &quot;</span><span style="color:#a3be8c;">Pizza Margherita</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        &quot;</span><span style="color:#a3be8c;">Caesar Salad</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        &quot;</span><span style="color:#a3be8c;">Quinoa Bowl</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> dispatcher = </span><span style="color:#96b5b4;">create_order_dispatcher</span><span>(daily_orders);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Dispatching today&#39;s orders:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> order in dispatcher {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Order prepared: </span><span style="color:#d08770;">{}</span><span>&quot;, order);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 2: Iterator with Borrowed Data - Menu Viewer
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">2Ô∏è‚É£ Iterator with Borrowed Data - Menu Viewer:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// When your iterator needs to return references to existing data (e.g., from a Vec)
</span><span>    </span><span style="color:#a7adba;">// you need to manage lifetimes.
</span><span>    </span><span style="color:#b48ead;">struct </span><span>MenuViewer&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; { </span><span style="color:#a7adba;">// The lifetime parameter &#39;a indicates it borrows data
</span><span>        </span><span style="color:#bf616a;">menu_items</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a </span><span>Vec&lt;String&gt;, </span><span style="color:#a7adba;">// Borrows the Vec
</span><span>        </span><span style="color:#bf616a;">current_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl</span><span>&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; Iterator </span><span style="color:#b48ead;">for </span><span>MenuViewer&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = &amp;</span><span style="color:#b48ead;">&#39;a </span><span>String; </span><span style="color:#a7adba;">// Item is a reference to a String
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.current_index &lt; </span><span style="color:#bf616a;">self</span><span>.menu_items.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>                </span><span style="color:#b48ead;">let</span><span> item = &amp;</span><span style="color:#bf616a;">self</span><span>.menu_items[</span><span style="color:#bf616a;">self</span><span>.current_index]; </span><span style="color:#a7adba;">// Return a reference
</span><span>                </span><span style="color:#bf616a;">self</span><span>.current_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>                println!(&quot;</span><span style="color:#a3be8c;">     [VIEW] Viewing menu item #</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">...</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.current_index);
</span><span>                Some(item)
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                None
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper method to create a MenuViewer for a Restaurant
</span><span>    </span><span style="color:#b48ead;">struct </span><span>Restaurant {
</span><span>        </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">menu</span><span>: Vec&lt;String&gt;,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Restaurant {
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">name</span><span>: String, </span><span style="color:#bf616a;">menu</span><span>: Vec&lt;String&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>            Restaurant { name, menu }
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#a7adba;">// This method allows iterating over references to the restaurant&#39;s menu
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">view_menu</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; MenuViewer {
</span><span>            MenuViewer {
</span><span>                menu_items: &amp;</span><span style="color:#bf616a;">self</span><span>.menu, </span><span style="color:#a7adba;">// Borrows self.menu
</span><span>                current_index: </span><span style="color:#d08770;">0</span><span>,
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_restaurant = Restaurant::new(
</span><span>        &quot;</span><span style="color:#a3be8c;">Green Garden Bistro</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        vec![
</span><span>            &quot;</span><span style="color:#a3be8c;">Pizza Margherita</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>            &quot;</span><span style="color:#a3be8c;">Caesar Salad</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>            &quot;</span><span style="color:#a3be8c;">Quinoa Bowl</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        ],
</span><span>    );
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Viewing restaurant menu (references):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> item in my_restaurant.</span><span style="color:#96b5b4;">view_menu</span><span>() { </span><span style="color:#a7adba;">// Iterate over references
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Menu item: </span><span style="color:#d08770;">{}</span><span>&quot;, item);
</span><span>    }
</span><span>    </span><span style="color:#a7adba;">// `my_restaurant` is still valid here, as its data was only borrowed
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Example 3: `IntoIterator` for Consuming Data
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">3Ô∏è‚É£ `IntoIterator` for Consuming Data - Automatic Dispenser Creation:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// The `IntoIterator` trait often works by moving data out of the collection.
</span><span>    </span><span style="color:#a7adba;">// Here, we adapt our OrderDispatcher to work with `IntoIterator` for `Vec&lt;String&gt;`.
</span><span>
</span><span>    </span><span style="color:#b48ead;">struct </span><span>OrderList {
</span><span>        </span><span style="color:#bf616a;">orders</span><span>: Vec&lt;String&gt;,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterator struct for OrderList (takes ownership of the Vec)
</span><span>    </span><span style="color:#b48ead;">struct </span><span>OrderListIntoIterator {
</span><span>        </span><span style="color:#bf616a;">orders_iter</span><span>: std::vec::IntoIter&lt;String&gt;, </span><span style="color:#a7adba;">// Delegates to Vec&#39;s into_iter
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>OrderListIntoIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = String;
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#bf616a;">self</span><span>.orders_iter.</span><span style="color:#96b5b4;">next</span><span>()
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>IntoIterator </span><span style="color:#b48ead;">for </span><span>OrderList {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = String;
</span><span>        </span><span style="color:#b48ead;">type </span><span>IntoIter = OrderListIntoIterator;
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">into_iter</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">Self::</span><span>IntoIter {
</span><span>            OrderListIntoIterator {
</span><span>                orders_iter: </span><span style="color:#bf616a;">self</span><span>.orders.</span><span style="color:#96b5b4;">into_iter</span><span>() </span><span style="color:#a7adba;">// Consumes the inner Vec
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> todays_orders = OrderList {
</span><span>        orders: vec![
</span><span>            &quot;</span><span style="color:#a3be8c;">Lunch Order 1</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>            &quot;</span><span style="color:#a3be8c;">Dinner Order 2</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        ],
</span><span>    };
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Processing orders for the day (consuming list):</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> order in todays_orders { </span><span style="color:#a7adba;">// `todays_orders` is consumed here
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Processing order: </span><span style="color:#d08770;">{}</span><span>&quot;, order);
</span><span>    }
</span><span>    </span><span style="color:#a7adba;">// `todays_orders` is no longer accessible after the loop
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">üéØ How Custom Iterators Work Summary:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ State is stored directly in the iterator struct.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `next(&amp;mut self)` mutates this state to track progress.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `Option&lt;Self::Item&gt;` signifies items or exhaustion.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Lifetimes are crucial when returning references (`&amp;&#39;a Item`).</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ `IntoIterator` enables direct `for` loop usage by consuming the collection.</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_how_custom_iterators_work</span><span>();
</span><span>}
</span></code></pre>
<h2 id="real-world-custom-iterator-applications">Real-World Custom Iterator Applications</h2>
<h3 id="complete-restaurant-management-system-implementation">Complete Restaurant Management System Implementation</h3>
<p><strong>Practical examples showing how custom iterators are used in real applications:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">demonstrate_real_world_custom_iterators</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">üè¢ Real-World Custom Iterators - Restaurant Management Systems</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:=&lt;75}</span><span>&quot;, &quot;&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::collections::HashMap;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Real-world applications use custom iterators for complex sequential data access
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">üíº Professional Custom Iterator Applications:</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Application 1: Filtered Order Stream Iterator
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">1Ô∏è‚É£ Filtered Order Stream - Only VIP Orders:</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>CustomerOrder {
</span><span>        </span><span style="color:#bf616a;">id</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>        </span><span style="color:#bf616a;">customer_name</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">is_vip</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>        </span><span style="color:#bf616a;">total</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterator that filters only VIP orders
</span><span>    </span><span style="color:#b48ead;">struct </span><span>VipOrderIterator {
</span><span>        </span><span style="color:#bf616a;">orders</span><span>: std::vec::IntoIter&lt;CustomerOrder&gt;, </span><span style="color:#a7adba;">// Iterator over raw orders
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>VipOrderIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = CustomerOrder; </span><span style="color:#a7adba;">// We&#39;ll return owned CustomerOrder structs
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#a7adba;">// Keep calling next until a VIP order is found or iterator is exhausted
</span><span>            </span><span style="color:#bf616a;">self</span><span>.orders.</span><span style="color:#96b5b4;">find</span><span>(|</span><span style="color:#bf616a;">order</span><span>| order.is_vip)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function to create a VIP order iterator from a Vec
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vip_orders</span><span>(</span><span style="color:#bf616a;">orders</span><span>: Vec&lt;CustomerOrder&gt;) -&gt; VipOrderIterator {
</span><span>        VipOrderIterator {
</span><span>            orders: orders.</span><span style="color:#96b5b4;">into_iter</span><span>(),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> daily_orders = vec![
</span><span>        CustomerOrder { id: </span><span style="color:#d08770;">101</span><span>, customer_name: &quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), is_vip: </span><span style="color:#d08770;">false</span><span>, total: </span><span style="color:#d08770;">25.0 </span><span>},
</span><span>        CustomerOrder { id: </span><span style="color:#d08770;">102</span><span>, customer_name: &quot;</span><span style="color:#a3be8c;">Bob</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), is_vip: </span><span style="color:#d08770;">true</span><span>, total: </span><span style="color:#d08770;">50.0 </span><span>},
</span><span>        CustomerOrder { id: </span><span style="color:#d08770;">103</span><span>, customer_name: &quot;</span><span style="color:#a3be8c;">Carol</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), is_vip: </span><span style="color:#d08770;">false</span><span>, total: </span><span style="color:#d08770;">15.0 </span><span>},
</span><span>        CustomerOrder { id: </span><span style="color:#d08770;">104</span><span>, customer_name: &quot;</span><span style="color:#a3be8c;">David</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), is_vip: </span><span style="color:#d08770;">true</span><span>, total: </span><span style="color:#d08770;">75.0 </span><span>},
</span><span>        CustomerOrder { id: </span><span style="color:#d08770;">105</span><span>, customer_name: &quot;</span><span style="color:#a3be8c;">Eve</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), is_vip: </span><span style="color:#d08770;">false</span><span>, total: </span><span style="color:#d08770;">30.0 </span><span>},
</span><span>    ];
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Processing only VIP orders:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> order in </span><span style="color:#96b5b4;">vip_orders</span><span>(daily_orders.</span><span style="color:#96b5b4;">clone</span><span>()) { </span><span style="color:#a7adba;">// Clone because daily_orders moved
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     VIP Order ID: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> by </span><span style="color:#d08770;">{}</span><span>&quot;, order.id, order.customer_name);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// This custom iterator is equivalent to daily_orders.into_iter().filter(|o| o.is_vip)
</span><span>    </span><span style="color:#a7adba;">// but demonstrates building a custom adaptor.
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Application 2: Menu Item Combination Iterator
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">2Ô∏è‚É£ Menu Item Combination Iterator - Suggesting Pairings:</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone, PartialEq, Eq, Hash)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>MenuItem {
</span><span>        </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">category</span><span>: String,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterator that generates all unique pairs of menu items
</span><span>    </span><span style="color:#b48ead;">struct </span><span>MenuPairIterator {
</span><span>        </span><span style="color:#bf616a;">items</span><span>: Vec&lt;MenuItem&gt;,
</span><span>        </span><span style="color:#bf616a;">i</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>        </span><span style="color:#bf616a;">j</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>MenuPairIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = (MenuItem, MenuItem); </span><span style="color:#a7adba;">// Returns a pair of menu items
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.i &gt;= </span><span style="color:#bf616a;">self</span><span>.items.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>                </span><span style="color:#b48ead;">return </span><span>None; </span><span style="color:#a7adba;">// Outer loop exhausted
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.j &gt;= </span><span style="color:#bf616a;">self</span><span>.items.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>                </span><span style="color:#bf616a;">self</span><span>.i += </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#a7adba;">// Move to next item in outer loop
</span><span>                </span><span style="color:#bf616a;">self</span><span>.j = </span><span style="color:#bf616a;">self</span><span>.i + </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#a7adba;">// Start inner loop after current outer item
</span><span>                </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">next</span><span>(); </span><span style="color:#a7adba;">// Recurse to find next valid pair
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.i &gt;= </span><span style="color:#bf616a;">self</span><span>.items.</span><span style="color:#96b5b4;">len</span><span>() || </span><span style="color:#bf616a;">self</span><span>.j &gt;= </span><span style="color:#bf616a;">self</span><span>.items.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>                </span><span style="color:#b48ead;">return </span><span>None; </span><span style="color:#a7adba;">// Ensure indices are valid after increment
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">let</span><span> item1 = </span><span style="color:#bf616a;">self</span><span>.items[</span><span style="color:#bf616a;">self</span><span>.i].</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>            </span><span style="color:#b48ead;">let</span><span> item2 = </span><span style="color:#bf616a;">self</span><span>.items[</span><span style="color:#bf616a;">self</span><span>.j].</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>
</span><span>            </span><span style="color:#bf616a;">self</span><span>.j += </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#a7adba;">// Increment inner loop index for next call
</span><span>            Some((item1, item2))
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function to create the MenuPairIterator
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">menu_item_pairs</span><span>(</span><span style="color:#bf616a;">items</span><span>: Vec&lt;MenuItem&gt;) -&gt; MenuPairIterator {
</span><span>        MenuPairIterator {
</span><span>            items,
</span><span>            i: </span><span style="color:#d08770;">0</span><span>,
</span><span>            j: </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#a7adba;">// Start j from i+1 to get unique pairs
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> menu = vec![
</span><span>        MenuItem { name: &quot;</span><span style="color:#a3be8c;">Pizza</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), category: &quot;</span><span style="color:#a3be8c;">Main</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>() },
</span><span>        MenuItem { name: &quot;</span><span style="color:#a3be8c;">Salad</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), category: &quot;</span><span style="color:#a3be8c;">Appetizer</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>() },
</span><span>        MenuItem { name: &quot;</span><span style="color:#a3be8c;">Coke</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), category: &quot;</span><span style="color:#a3be8c;">Beverage</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>() },
</span><span>        MenuItem { name: &quot;</span><span style="color:#a3be8c;">Pasta</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), category: &quot;</span><span style="color:#a3be8c;">Main</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>() },
</span><span>    ];
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Generating menu item pairings:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(item1, item2) in </span><span style="color:#96b5b4;">menu_item_pairs</span><span>(menu.</span><span style="color:#96b5b4;">clone</span><span>()) { </span><span style="color:#a7adba;">// Clone because menu moved
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Pair: </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;"> &amp; </span><span style="color:#d08770;">{:?}</span><span>&quot;, item1.name, item2.name);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Application 3: Daily Sales Report Generator
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">3Ô∏è‚É£ Daily Sales Report Generator - Aggregating Transactions:</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>SaleRecord {
</span><span>        </span><span style="color:#bf616a;">item_name</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">price</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>        </span><span style="color:#bf616a;">quantity</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterator that aggregates sales records by item name
</span><span>    </span><span style="color:#b48ead;">struct </span><span>SalesReportIterator {
</span><span>        </span><span style="color:#bf616a;">sales_by_item</span><span>: std::collections::hash_map::IntoIter&lt;String, (</span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>)&gt;, </span><span style="color:#a7adba;">// (total_revenue, total_quantity)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>SalesReportIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = (String, </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>); </span><span style="color:#a7adba;">// (item_name, total_revenue, total_quantity)
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#bf616a;">self</span><span>.sales_by_item.</span><span style="color:#96b5b4;">next</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|(</span><span style="color:#bf616a;">name</span><span>, (</span><span style="color:#bf616a;">revenue</span><span>, </span><span style="color:#bf616a;">quantity</span><span>))| {
</span><span>                (name, revenue, quantity)
</span><span>            })
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function to create a SalesReportIterator
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_sales_report</span><span>(</span><span style="color:#bf616a;">raw_sales</span><span>: Vec&lt;SaleRecord&gt;) -&gt; SalesReportIterator {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> aggregated_sales: HashMap&lt;String, (</span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>)&gt; = HashMap::new();
</span><span>
</span><span>        </span><span style="color:#b48ead;">for</span><span> record in raw_sales {
</span><span>            </span><span style="color:#b48ead;">let </span><span>(total_revenue, total_quantity) = aggregated_sales
</span><span>                .</span><span style="color:#96b5b4;">entry</span><span>(record.item_name)
</span><span>                .</span><span style="color:#96b5b4;">or_insert</span><span>((</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0</span><span>));
</span><span>
</span><span>            *total_revenue += record.price * record.quantity as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            *total_quantity += record.quantity;
</span><span>        }
</span><span>
</span><span>        SalesReportIterator { sales_by_item: aggregated_sales.</span><span style="color:#96b5b4;">into_iter</span><span>() }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> daily_transactions = vec![
</span><span>        SaleRecord { item_name: &quot;</span><span style="color:#a3be8c;">Pizza</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), price: </span><span style="color:#d08770;">15.99</span><span>, quantity: </span><span style="color:#d08770;">1 </span><span>},
</span><span>        SaleRecord { item_name: &quot;</span><span style="color:#a3be8c;">Coke</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), price: </span><span style="color:#d08770;">2.50</span><span>, quantity: </span><span style="color:#d08770;">2 </span><span>},
</span><span>        SaleRecord { item_name: &quot;</span><span style="color:#a3be8c;">Pizza</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), price: </span><span style="color:#d08770;">15.99</span><span>, quantity: </span><span style="color:#d08770;">1 </span><span>},
</span><span>        SaleRecord { item_name: &quot;</span><span style="color:#a3be8c;">Salad</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), price: </span><span style="color:#d08770;">10.00</span><span>, quantity: </span><span style="color:#d08770;">1 </span><span>},
</span><span>        SaleRecord { item_name: &quot;</span><span style="color:#a3be8c;">Coke</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), price: </span><span style="color:#d08770;">2.50</span><span>, quantity: </span><span style="color:#d08770;">1 </span><span>},
</span><span>    ];
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Generating daily sales report:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for </span><span>(item, revenue, quantity) in </span><span style="color:#96b5b4;">generate_sales_report</span><span>(daily_transactions) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Item: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> | Revenue: $</span><span style="color:#d08770;">{:.2}</span><span style="color:#a3be8c;"> | Quantity: </span><span style="color:#d08770;">{}</span><span>&quot;, item, revenue, quantity);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Application 4: Restaurant Shift Iterator
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">4Ô∏è‚É£ Restaurant Shift Iterator - Generating Work Schedules:</span><span>&quot;);
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone)]
</span><span>    </span><span style="color:#b48ead;">enum </span><span>ShiftType {
</span><span>        Morning,
</span><span>        Evening,
</span><span>        Night,
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone)]
</span><span>    </span><span style="color:#b48ead;">struct </span><span>Shift {
</span><span>        </span><span style="color:#bf616a;">day</span><span>: String,
</span><span>        </span><span style="color:#bf616a;">shift_type</span><span>: ShiftType,
</span><span>        </span><span style="color:#bf616a;">staff_assigned</span><span>: String,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Iterator that generates shifts for a week
</span><span>    </span><span style="color:#b48ead;">struct </span><span>WeeklyShiftIterator {
</span><span>        </span><span style="color:#bf616a;">days</span><span>: std::vec::IntoIter&lt;String&gt;,
</span><span>        </span><span style="color:#bf616a;">shift_types</span><span>: std::vec::IntoIter&lt;ShiftType&gt;,
</span><span>        </span><span style="color:#bf616a;">staff_names</span><span>: Vec&lt;String&gt;,
</span><span>        </span><span style="color:#bf616a;">current_staff_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>WeeklyShiftIterator {
</span><span>        </span><span style="color:#b48ead;">type </span><span>Item = Shift;
</span><span>
</span><span>        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>            </span><span style="color:#a7adba;">// Get next shift type (cycle through morning, evening, night)
</span><span>            </span><span style="color:#b48ead;">if let </span><span>Some(shift_type) = </span><span style="color:#bf616a;">self</span><span>.shift_types.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>                </span><span style="color:#a7adba;">// Get next day
</span><span>                </span><span style="color:#b48ead;">if let </span><span>Some(day) = </span><span style="color:#bf616a;">self</span><span>.days.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>                    </span><span style="color:#a7adba;">// Assign staff
</span><span>                    </span><span style="color:#b48ead;">let</span><span> staff = </span><span style="color:#bf616a;">self</span><span>.staff_names[</span><span style="color:#bf616a;">self</span><span>.current_staff_index % </span><span style="color:#bf616a;">self</span><span>.staff_names.</span><span style="color:#96b5b4;">len</span><span>()].</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.current_staff_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>                    </span><span style="color:#b48ead;">return </span><span>Some(Shift { day, shift_type, staff_assigned: staff });
</span><span>                }
</span><span>            }
</span><span>
</span><span>            None </span><span style="color:#a7adba;">// All shifts for all days generated
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Helper function
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_weekly_shifts</span><span>(</span><span style="color:#bf616a;">staff</span><span>: Vec&lt;String&gt;) -&gt; WeeklyShiftIterator {
</span><span>        </span><span style="color:#b48ead;">let</span><span> days = vec![&quot;</span><span style="color:#a3be8c;">Monday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Tuesday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Wednesday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Thursday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Friday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Saturday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Sunday</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()];
</span><span>        </span><span style="color:#b48ead;">let</span><span> shift_types = vec![ShiftType::Morning, ShiftType::Evening, ShiftType::Night];
</span><span>
</span><span>        WeeklyShiftIterator {
</span><span>            days: days.</span><span style="color:#96b5b4;">into_iter</span><span>(),
</span><span>            shift_types: shift_types.</span><span style="color:#96b5b4;">into_iter</span><span>(),
</span><span>            staff_names: staff,
</span><span>            current_staff_index: </span><span style="color:#d08770;">0</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> staff_for_week = vec![&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Bob</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Charlie</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()];
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   Generating weekly shifts:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> shift in </span><span style="color:#96b5b4;">generate_weekly_shifts</span><span>(staff_for_week) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">     Schedule: </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;"> on </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> (Assigned: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">)</span><span>&quot;, shift.shift_type, shift.day, shift.staff_assigned);
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">üéØ Real-World Custom Iterator Benefits:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Decouple data generation from data processing.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Create lazy data streams for complex scenarios.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Integrate seamlessly with Rust&#39;s iterator ecosystem (adaptors, consumers).</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Encapsulate complex state management within the iterator struct.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Promote functional programming style for data pipelines.</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">üí° Professional Implementation Guidelines:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Prefer implementing `Iterator` for a separate &#39;state&#39; struct, then `IntoIterator` for your main collection.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Use `find`, `filter`, `map` within `next()` if the custom iterator is a &#39;wrapper&#39; or &#39;filterer&#39;.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Be mindful of ownership (`&amp;&#39;a Self::Item` vs `Self::Item`) and lifetimes.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Document the iteration behavior and the `Item` type clearly.</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">   ‚Ä¢ Benchmark custom iterators if performance is critical.</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">demonstrate_real_world_custom_iterators</span><span>();
</span><span>}
</span></code></pre>
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<h3 id="mental-model-the-complete-professional-kitchen-dispenser-system"><strong>Mental Model: The Complete Professional Kitchen Dispenser System</strong></h3>
<p>Remember our comprehensive professional kitchen dispenser analogy:</p>
<ul>
<li>üè≠ <strong>Custom iterator</strong> = <strong>Specialized food dispenser</strong> - Provides items efficiently, one by one.</li>
<li>üìã <strong><code>Iterator</code> trait</strong> = <strong>Dispenser blueprint</strong> - Defines the <code>next()</code> method and <code>Item</code> type.</li>
<li>‚öôÔ∏è <strong>State management</strong> = <strong>Dispenser mechanics</strong> - Internal variables track progress.</li>
<li><code>IntoIterator</code> trait = <strong>Automatic dispenser creation</strong> - Allows direct use in <code>for</code> loops.</li>
<li>üîÑ <strong>Composition</strong> = <strong>Seamless integration</strong> - Works with all standard iterator adaptors and consumers.</li>
</ul>
<h3 id="essential-concepts-for-custom-iterators"><strong>Essential Concepts for Custom Iterators</strong></h3>
<p><strong>The <code>Iterator</code> Trait:</strong></p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub trait </span><span>Iterator {
</span><span>    </span><span style="color:#a7adba;">// Associated type: The type of items this iterator produces
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// The only required method:
</span><span>    </span><span style="color:#a7adba;">//   - Returns `Some(value)` for the next item
</span><span>    </span><span style="color:#a7adba;">//   - Returns `None` when the iterator is exhausted
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt;;
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Many default methods (map, filter, fold, sum, count, etc.) are provided for free!
</span><span>}
</span></code></pre>
<p><strong>Implementing a Custom Iterator:</strong></p>
<ol>
<li><strong>Define a struct</strong>: This struct will hold the internal state of your iterator.</li>
</ol>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>MyIteratorState {
</span><span>    </span><span style="color:#a7adba;">// ... fields to track current position, data, etc.
</span><span>    </span><span style="color:#bf616a;">current_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#bf616a;">data</span><span>: Vec&lt;String&gt;, </span><span style="color:#a7adba;">// Example: data to iterate over
</span><span>}
</span></code></pre>
<ol start="2">
<li><strong>Implement <code>Iterator</code> for your state struct</strong>:</li>
</ol>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>MyIteratorState {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item = String; </span><span style="color:#a7adba;">// Specify the type of items produced
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.current_index &lt; </span><span style="color:#bf616a;">self</span><span>.data.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> item = </span><span style="color:#bf616a;">self</span><span>.data[</span><span style="color:#bf616a;">self</span><span>.current_index].</span><span style="color:#96b5b4;">clone</span><span>(); </span><span style="color:#a7adba;">// Or return &amp;Item if borrowing
</span><span>            </span><span style="color:#bf616a;">self</span><span>.current_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>            Some(item)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            None </span><span style="color:#a7adba;">// Iterator is exhausted
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>The <code>IntoIterator</code> Trait:</strong></p>
<ul>
<li>Allows your custom collection type (e.g., <code>RecipeBook</code>) to be used directly in a <code>for</code> loop (e.g., <code>for recipe in my_recipe_book</code>).</li>
<li>It requires defining an <code>IntoIter</code> associated type, which is the actual iterator struct (e.g., <code>RecipeBookIterator</code>).</li>
<li><code>into_iter()</code> typically consumes the collection it's iterating over.</li>
</ul>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>IntoIterator </span><span style="color:#b48ead;">for </span><span>RecipeBook {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item = String; </span><span style="color:#a7adba;">// Item type that the iterator produces
</span><span>    </span><span style="color:#b48ead;">type </span><span>IntoIter = RecipeBookIterator; </span><span style="color:#a7adba;">// The actual iterator struct
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">into_iter</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">Self::</span><span>IntoIter {
</span><span>        </span><span style="color:#a7adba;">// Create and return an instance of your iterator struct
</span><span>        RecipeBookIterator { </span><span style="color:#a7adba;">/* ... */ </span><span>}
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="how-custom-iterators-work-internally"><strong>How Custom Iterators Work Internally</strong></h3>
<ul>
<li><strong>State Storage</strong>: The <code>struct</code> defined for the iterator (e.g., <code>CountdownDispenser</code>, <code>OrderDispatcher</code>) holds all the necessary internal variables (like <code>current_index</code>, <code>a</code> and <code>b</code> for Fibonacci) to keep track of its progress.</li>
<li><strong><code>next()</code> Method Logic</strong>: Each call to <code>next(&amp;mut self)</code> performs the following steps:</li>
</ul>
<ol>
<li>Checks if there are more items to produce based on the current state.</li>
<li>If yes, retrieves or generates the next item.</li>
<li>Updates the internal state (<code>self.current_index += 1</code>, <code>self.a = self.b</code>, etc.) to prepare for the <em>next</em> call.</li>
<li>Returns <code>Some(item)</code>.</li>
<li>If no more items, returns <code>None</code>.</li>
</ol>
<ul>
<li><strong>Mutability</strong>: The <code>next</code> method takes <code>&amp;mut self</code> because it needs to modify the iterator's internal state with each call.</li>
<li><strong>Ownership/Borrowing</strong>: When creating an iterator:
<ul>
<li>If your <code>next()</code> returns <code>Self::Item</code> (owned value), the data is moved out of the iterator.</li>
<li>If your <code>next()</code> returns <code>&amp;'a Self::Item</code> (a reference), the iterator must borrow the data it's iterating over, and you need to manage lifetimes (<code>'a</code>).</li>
</ul>
</li>
</ul>
<h3 id="real-world-application-patterns"><strong>Real-World Application Patterns</strong></h3>
<ul>
<li><strong>Custom Data Streams</strong>: Generate sequences of data that don't naturally exist in a <code>Vec</code> (e.g., a stream of random numbers, a sequence of database records, complex combinatorial patterns).</li>
<li><strong>Lazy Filtering/Transformation</strong>: Create iterators that filter or transform data on demand, avoiding the creation of intermediate collections (e.g., <code>VipOrderIterator</code>).</li>
<li><strong>Complex Aggregation</strong>: Build iterators that perform internal aggregation or grouping before producing results (e.g., <code>SalesReportIterator</code>).</li>
<li><strong>Domain-Specific Sequences</strong>: Represent business logic as a sequence (e.g., <code>WeeklyShiftIterator</code> for staff scheduling, <code>MenuPairIterator</code> for dish combinations).</li>
<li><strong>Parsing/Tokenizing</strong>: Custom iterators can parse input streams and yield tokens or structured data one by one.</li>
</ul>
<h3 id="best-practices-checklist"><strong>Best Practices Checklist</strong></h3>
<p><strong>‚úÖ Design Guidelines:</strong></p>
<ul>
<li><strong>Separate Iterator State</strong>: For collections you own, implement <code>Iterator</code> on a <em>separate struct</em> that holds a reference or owns the data of the collection. Then implement <code>IntoIterator</code> for your main collection.</li>
<li><strong>Clear <code>Item</code> Type</strong>: Define <code>type Item</code> clearly to represent what the iterator produces.</li>
<li><strong>Mind Ownership &amp; Lifetimes</strong>: Decide if your <code>next()</code> should return owned items (<code>Self::Item</code>) or references (<code>&amp;'a Self::Item</code>), and handle lifetimes accordingly.</li>
<li><strong>Delegate when Possible</strong>: If your custom iterator wraps another iterable type (like <code>Vec</code>), you can often delegate <code>next()</code> calls to the inner iterator's <code>next()</code>.</li>
</ul>
<p><strong>‚úÖ Implementation Guidelines:</strong></p>
<ul>
<li><strong>State Management</strong>: Ensure your iterator struct correctly maintains its internal state between <code>next()</code> calls.</li>
<li><strong>Exhaustion Logic</strong>: Clearly define the condition under which <code>next()</code> returns <code>None</code>.</li>
<li><strong>Use Standard Adaptors</strong>: Leverage the power of existing iterator adaptors (<code>map</code>, <code>filter</code>, <code>flat_map</code>, <code>fold</code>, <code>collect</code>, etc.) after your custom iterator.</li>
</ul>
<p><strong>‚úÖ Performance Guidelines:</strong></p>
<ul>
<li><strong>Laziness</strong>: Custom iterators are inherently lazy. This avoids unnecessary computation and memory allocation until a consumer is called.</li>
<li><strong>Zero-Cost Abstraction</strong>: Rust's compiler heavily optimizes iterators, often generating machine code as efficient as hand-written loops.</li>
</ul>
<p><strong>‚ùå Common Pitfalls:</strong></p>
<ul>
<li>Forgetting to take <code>&amp;mut self</code> in the <code>next()</code> method.</li>
<li>Incorrectly handling lifetimes when returning references from <code>next()</code>.</li>
<li>Not updating the internal state correctly, leading to infinite loops or incorrect sequences.</li>
<li>Forgetting to implement <code>IntoIterator</code> if you want your main collection to be directly iterable in <code>for</code> loops.</li>
</ul>
<h3 id="the-professional-advantage"><strong>The Professional Advantage</strong></h3>
<p><strong>Mastering custom iterator implementations in Rust is like having complete control over your professional kitchen's food dispenser system</strong> - you can design automated, efficient, and precise methods for accessing any sequence of data:</p>
<ul>
<li>üîÑ <strong>Unified Interface</strong>: Seamlessly integrate your custom logic into Rust's powerful iterator ecosystem.</li>
<li>üéØ <strong>On-Demand Processing</strong>: Generate and provide data items only when requested, maximizing efficiency.</li>
<li>üìà <strong>Composability</strong>: Your custom iterators can be combined with all standard iterator adaptors for complex data pipelines.</li>
<li>üõ°Ô∏è <strong>Memory Safety</strong>: Rust's ownership and borrowing rules ensure safe state management and data access.</li>
<li>üé® <strong>Expressive Code</strong>: Write clear, functional-style code for sequence generation and processing.</li>
</ul>
<p><strong>Understanding custom iterator implementations transforms you from a programmer who manually loops through data to an architect</strong> who designs sophisticated, lazy data pipelines. Just as a master chef creates specialized dispensers for every ingredient, a skilled Rust programmer leverages custom iterators to build robust and highly performant data-driven applications.</p>
<p>This comprehensive understanding of custom iterator implementations - from the <code>Iterator</code> trait fundamentals through advanced state management and real-world applications - enables you to write Rust code that is both powerful and elegant, fully utilizing the language's capabilities for efficient data processing!</p>
<ol>
<li>https://doc.rust-lang.org/rust-by-example/trait/iter.html</li>
<li>https://dev.to/wrongbyte/implementing-iterator-and-intoiterator-in-rust-3nio</li>
<li>https://refactoring.guru/design-patterns/iterator/rust/example</li>
<li>https://stackoverflow.com/questions/73955577/implementing-a-custom-iterator-trait</li>
<li>https://notes.kodekloud.com/docs/Rust-Programming/Closures-and-Iterators/Rusts-Iterator-Ecosystem-Custom-Iterators</li>
<li>https://www.freecodecamp.org/news/rust-tutorial-build-a-json-parser/</li>
<li>https://www.risein.com/courses/rust-programming/introduction-to-iterator-and-its-types-in-rust</li>
<li>https://aloso.github.io/2021/03/09/creating-an-iterator</li>
<li>https://users.rust-lang.org/t/custom-iterator-over-some-struct-fields/53559</li>
<li>https://www.reddit.com/r/rust/comments/lrala6/custom_iterator_adapters/</li>
</ol>

    
        </div>

    </article>
</main>


    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/elasticlunr.min.js" defer></script>
    <script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/search_index.en.js" defer></script>
<script type="text/javascript" src="https://aarambhdevhub.github.io/rust-doc/js.js" defer></script>

</body>
</html>
